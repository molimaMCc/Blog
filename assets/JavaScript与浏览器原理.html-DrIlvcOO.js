import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as s,e}from"./app-otQn-0y1.js";const i={},t=e(`<h1 id="javascript与浏览器原理" tabindex="-1"><a class="header-anchor" href="#javascript与浏览器原理"><span>JavaScript与浏览器原理</span></a></h1><h2 id="浏览器模型" tabindex="-1"><a class="header-anchor" href="#浏览器模型"><span>浏览器模型</span></a></h2><h3 id="script元素" tabindex="-1"><a class="header-anchor" href="#script元素"><span>script元素</span></a></h3><p>####工作原理</p><p><strong>网页加载流程</strong>：</p><ol><li>浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。</li><li>解析过程中，浏览器发现<code>&lt;script&gt;</code>元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。</li><li>如果<code>&lt;script&gt;</code>元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。</li><li>JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页。</li></ol><p>造成的问题：</p><p>由于<code>js</code>脚本加载时间过长，浏览器会一直等待脚本下载完成，造成网页长时间未响应，浏览器呈现假死状态，这种称为**“阻塞效应”**</p><p>解决方案:</p><p>​ <code>DOMContentLoaded</code>事件回调函数，<code>DOMContentLoaded</code>事件只有在 DOM 结构生成之后才会触发</p><p>​ <code>script</code>标签的<code>onload</code>属性，当<code>&lt;script&gt;</code>标签指定的外部脚本文件下载和解析完成，会触发一个<code>load</code>事件，可以把所需执行的代码，放在这个事件的回调函数里面。</p><p><em><strong>但是，如果将脚本放在页面底部，就可以完全按照正常的方式写，上面两种方式都不需要。</strong></em></p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/html解析.jpeg" alt="html解析" tabindex="0" loading="lazy"><figcaption>html解析</figcaption></figure><p>解决“阻塞效应”</p><h4 id="defer" tabindex="-1"><a class="header-anchor" href="#defer"><span>defer</span></a></h4><p><code>defer</code>属性的运行流程如下。</p><ol><li>浏览器开始解析 HTML 网页。</li><li>解析过程中，发现带有<code>defer</code>属性的<code>&lt;script&gt;</code>元素。</li><li>浏览器继续往下解析 HTML 网页，同时并行下载<code>&lt;script&gt;</code>元素加载的外部脚本。</li><li>浏览器完成解析 HTML 网页，此时再回过头执行已经下载完成的脚本。</li></ol><p>有了<code>defer</code>属性，浏览器下载脚本文件的时候，不会阻塞页面渲染。下载的脚本文件在<code>DOMContentLoaded</code>事件触发前执行（即刚刚读取完<code>&lt;/html&gt;</code>标签），而且可以保证执行顺序就是它们在页面上出现的顺序。</p><h4 id="async" tabindex="-1"><a class="header-anchor" href="#async"><span>async</span></a></h4><p><code>async</code>属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。</p><ol><li>浏览器开始解析 HTML 网页。</li><li>解析过程中，发现带有<code>async</code>属性的<code>script</code>标签。</li><li>浏览器继续往下解析 HTML 网页，同时并行下载<code>&lt;script&gt;</code>标签中的外部脚本。</li><li>脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本。</li><li>脚本执行完毕，浏览器恢复解析 HTML 网页。</li></ol><h4 id="加载使用的协议" tabindex="-1"><a class="header-anchor" href="#加载使用的协议"><span>加载使用的协议</span></a></h4><p>如果不指定协议，浏览器默认采用 HTTP 协议下载</p><p>如果要采用 HTTPS 协议下载，必需写明。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;https://example.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是有时我们会希望，根据页面本身的协议来决定加载协议，这时可以采用下面的写法。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;//example.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="浏览器的组成" tabindex="-1"><a class="header-anchor" href="#浏览器的组成"><span>浏览器的组成</span></a></h3><ol><li><p>用户界面:</p><p>用户界面主要包括：地址栏，后退/前进按钮，书签目录等；（除了从服务器请求到的网页窗口）</p></li><li><p>浏览器引擎：</p><p>用来查询及操作渲染引擎的接口；</p></li><li><p>渲染引擎：</p><p>用来显示请求的html内容；（包括样式，图片，js）</p></li><li><p>网络：</p><p>主要是来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作；</p></li><li><p>UI后端：</p><p>用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。</p></li><li><p>JS解释器 ：</p><p>用来解释执行JS代码；</p></li><li><p>数据存储：</p><p>属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的， 客户端存储技术；</p></li></ol><p><strong>浏览器的核心是两部分</strong>：渲染引擎和 JavaScript 解释器（又称 JavaScript 引擎）</p><h4 id="渲染引擎" tabindex="-1"><a class="header-anchor" href="#渲染引擎"><span>渲染引擎</span></a></h4><p>渲染引擎处理网页，通常分成四个阶段。</p><ol><li>解析代码：HTML 代码解析为 DOM，CSS 代码解析为 CSSOM（CSS Object Model）。</li><li>对象合成：将 DOM 和 CSSOM 合成一棵渲染树（render tree）。</li><li>布局：计算出渲染树的布局（layout）。</li><li>绘制：将渲染树绘制到屏幕。</li></ol><p><em>以上四步并非严格按顺序执行，往往第一步还没完成，第二步和第三步就已经开始了。所以，会看到这种情况：网页的 HTML 代码还没下载完，但浏览器已经显示出内容了。</em></p><h4 id="回流与重绘" tabindex="-1"><a class="header-anchor" href="#回流与重绘"><span>回流与重绘</span></a></h4><p><strong>回流</strong>：DOM元素发生某种变化，渲染树(render tree)重新计算，浏览器对DOM树重新排列(布局改变)</p><p><strong>重绘</strong>：元素的外观发生改变，浏览器会根据元素的新属性重新绘制样式。(布局不改变)</p><p><strong>回流一定发生重绘，重绘不一定发生回流</strong></p><p>优化技巧尽量避免回流与重绘：</p><ul><li>读取 DOM 或者写入 DOM，尽量写在一起，不要混杂。不要读取一个 DOM 节点，然后立刻写入，接着再读取一个 DOM 节点。</li><li>缓存 DOM 信息。</li><li>不要一项一项地改变样式，而是使用 CSS class 一次性改变样式。</li><li>使用<code>documentFragment</code>操作 DOM</li><li>动画使用<code>absolute</code>定位或<code>fixed</code>定位，这样可以减少对其他元素的影响。</li><li>只在必要时才显示隐藏元素。</li><li>使用<code>window.requestAnimationFrame()</code>，因为它可以把代码推迟到下一次重绘之前执行，而不是立即要求页面重绘。</li><li>使用虚拟 DOM（virtual DOM）库。</li></ul><h2 id="javascript运行机制" tabindex="-1"><a class="header-anchor" href="#javascript运行机制"><span>JavaScript运行机制</span></a></h2><h3 id="浏览器的组成-1" tabindex="-1"><a class="header-anchor" href="#浏览器的组成-1"><span>浏览器的组成</span></a></h3><h4 id="浏览器的进程" tabindex="-1"><a class="header-anchor" href="#浏览器的进程"><span>浏览器的进程</span></a></h4><p>浏览器的是多进程的，它的主要进程有：</p><p><strong>1.Browser进程：浏览器的主进程（负责协调、主控），只有一个。</strong></p><ul><li>负责浏览器界面显示，与用户交互。如前进，后退等</li><li>负责各个页面的管理，创建和销毁其他进程</li><li>将Renderer进程得到的内存中的Bitmap，绘制到用户界面上</li><li>网络资源的管理，下载等</li></ul><p><strong>2.第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</strong></p><p><strong>3、GPU进程：最多一个，用于3D绘制等</strong></p><p>4、<strong>浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为：页面渲染，脚本执行，事件处理等</strong></p><blockquote><p>在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程） 当然，浏览器有时会将多个进程合并（譬如打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程）。</p></blockquote><h4 id="浏览器多进程的优势" tabindex="-1"><a class="header-anchor" href="#浏览器多进程的优势"><span>浏览器多进程的优势</span></a></h4><p>相比于单进程浏览器，多进程有如下优点： 1、避免单个page crash影响整个浏览器 2、避免第三方插件crash影响整个浏览器 3、多进程充分利用多核优势 4、方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</p><h4 id="浏览器的内核-渲染进程" tabindex="-1"><a class="header-anchor" href="#浏览器的内核-渲染进程"><span>浏览器的内核-渲染进程</span></a></h4><p>页面的渲染，JS的执行，事件的循环，都在这个进程内进行。</p><p>渲染进程主要包含的线程：</p><p><strong>1.GUI渲染线程</strong></p><ul><li>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</li><li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</li><li>注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</li></ul><p><strong>2.JS引擎线程</strong></p><ul><li>也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）</li><li>JS引擎线程负责解析Javascript脚本，运行代码。</li><li>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</li><li>同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li></ul><p><strong>3.事件触发线程</strong></p><ul><li>归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</li><li>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</li><li>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</li></ul><p><strong>4.定时触发器线程</strong></p><ul><li>传说中的setInterval与setTimeout所在线程</li><li>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</li><li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</li><li>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</li></ul><p><strong>5.异步http请求线程</strong></p><ul><li>在XMLHttpRequest连接后是通过浏览器新开一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由JavaScript引擎执行。</li><li>简单说就是当执行到一个http异步请求时，就把异步请求事件添加到异步请求线程，等收到响应(准确来说应该是http状态变化)，再把回调函数添加到事件队列，等待js引擎线程来执行</li></ul><h3 id="事件循环" tabindex="-1"><a class="header-anchor" href="#事件循环"><span>事件循环</span></a></h3><h4 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h4><p>JS是单线程语言，规定了同一时间只能做一件事情，为什么？</p><p>因为JS是浏览器脚本语言，是用来与用户交互的，操作DOM的。这个特性决定JS是单线程语言，否则会带来很多复杂问题，例如，如果JS是多线程，那么一个线程在DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器是怎么做？所以JS只能是单线程。</p><h4 id="异步" tabindex="-1"><a class="header-anchor" href="#异步"><span>异步</span></a></h4><p>JS为什么需要异步？</p><p>JS代码执行是从上至下，如果有一段代码需要发送请求那么就会阻塞下面的代码执行。用户体验就会很差。</p><p><strong>JS中的异步操作</strong></p><ul><li>定时器（setTimeout）（setInterval）</li><li>回调函数</li><li>监听事件</li><li>AJAX请求</li><li>promise</li><li>生成器函数</li></ul><h4 id="js运行机制" tabindex="-1"><a class="header-anchor" href="#js运行机制"><span>JS运行机制</span></a></h4><p>先判断是同步任务还是异步任务</p><p>JS同步任务在主线程完成，形成一个执行栈（从上至下依次执行）</p><p>异步任务会先推入Event table，当满足特定的条件时（请求状态发生变化，定时器时间到了）就会被推入事件触发线程管理的异步任务队列（Event queue） 注册一个回调函数。一旦执行栈中所有的同步任务执行完成，就会读取任务队列，将可以运行的异步任务（任务队列中的事件回调，只要任务队列中有事件回调，就说明可以执行）添加到执行栈中，开始执行</p><blockquote><p>注意：队列是先进先出</p></blockquote><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/ltw003.png" alt="未命名文件-导出" tabindex="0" loading="lazy"><figcaption>未命名文件-导出</figcaption></figure><h4 id="宏任务与微任务" tabindex="-1"><a class="header-anchor" href="#宏任务与微任务"><span>宏任务与微任务</span></a></h4><p>**宏任务（macrotask）**也叫task</p><p>我们可以将每次执行栈执行的代码当做是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)， 每一个宏任务会从头到尾执行完毕，不会执行其他</p><p>由于<strong>JS引擎线程</strong>和<strong>GUI渲染线程</strong>是互斥的关系，浏览器为了能够使<code>宏任务</code>和<code>DOM任务</code>有序的进行，会在一个<code>宏任务</code>执行结果后，在下一个<code>宏任务</code>执行前，<code>GUI渲染线程</code>开始工作，对页面进行渲染</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>宏任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; ...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>常见的宏任务：</p><ul><li>主代码块（script标签代码）</li><li>setTimeout</li><li>setInterval</li><li>setImmediate ()-Node</li><li>requestAnimationFrame ()-浏览器</li></ul><p><strong>微任务</strong>（microtask）也叫jobs</p><p>微任务是当前宏任务执行完后立即执行的任务，当一个<code>宏任务</code>执行完，会在渲染前，将执行期间所产生的所有<strong>微任务</strong>都执行完</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>宏任务 -&gt; 微任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; ...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>常见微任务：</p><ul><li>process.nextTick ()-Node环境</li><li>Promise.then()</li><li>promise的catch</li><li>promise的finally</li><li>Object.observe</li><li>MutationObserver</li></ul><p><strong>注意点：</strong></p><ul><li><p>浏览器会先执行一个宏任务，紧接着执行当前执行栈产生的微任务，再进行渲染，然后再执行下一个宏任务</p></li><li><p>微任务和宏任务不在一个任务队列，不在一个任务队列</p></li><li><ul><li>例如<code>setTimeout</code>是一个宏任务，它的事件回调在宏任务队列，<code>Promise.then()</code>是一个微任务，它的事件回调在微任务队列，二者并不是一个任务队列</li><li>以Chrome 为例，有关渲染的都是在渲染进程中执行，渲染进程中的任务（DOM树构建，js解析…等等）需要主线程执行的任务都会在主线程中执行，而浏览器维护了一套事件循环机制，主线程上的任务都会放到消息队列中执行，主线程会循环消息队列，并从头部取出任务进行执行，如果执行过程中产生其他任务需要主线程执行的，渲染进程中的其他线程会把该任务塞入到消息队列的尾部，消息队列中的任务都是宏任务</li><li>微任务是如何产生的呢？当执行到script脚本的时候，js引擎会为全局创建一个执行上下文，在该执行上下文中维护了一个微任务队列，当遇到微任务，就会把微任务回调放在微队列中，当所有的js代码执行完毕，在退出全局上下文之前引擎会去检查该队列，有回调就执行，没有就退出执行上下文，这也就是为什么微任务要早于宏任务，也是大家常说的，每个宏任务都有一个微任务队列（由于定时器是浏览器的API，所以定时器是宏任务，在js中遇到定时器会也是放入到浏览器的队列中</li></ul></li></ul><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-858bcd85eb943a853cdbaf3ba7227985_720w.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>完整的Event Loop</strong></p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/ltw001.png" alt="ltw001" tabindex="0" loading="lazy"><figcaption>ltw001</figcaption></figure><h3 id="垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#垃圾回收机制"><span>垃圾回收机制</span></a></h3><h4 id="_1-引用计数法" tabindex="-1"><a class="header-anchor" href="#_1-引用计数法"><span>1.引用计数法</span></a></h4><p><strong>引用计数法</strong>：如果有一个变量，指向访问我的一块内存空间，计数器就会加1，如果计数器为0，就会被立即清除</p><p>存在于低版本的浏览器（IE8以下）</p><p>优点：</p><ul><li>时刻检测内存变化</li><li>能够降低内存卡顿情况</li></ul><p>缺点：</p><ul><li>性能开销大</li><li>造成循环引用问题（计数器不会为零无法被清除）</li></ul><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/Snipaste_2022-11-01_21-33-21.png" alt="Snipaste_2022-11-01_21-33-21" tabindex="0" loading="lazy"><figcaption>Snipaste_2022-11-01_21-33-21</figcaption></figure><h4 id="_2-标记清除法" tabindex="-1"><a class="header-anchor" href="#_2-标记清除法"><span>2.标记清除法</span></a></h4><p><strong>标记清除法</strong>：分为两个阶段</p><p>标记阶段：垃圾回收器会从根对象开始扫描(在js中，通常认定全局对象window做为根)。每一个可以从根对象访问到的对象都会被添加一个标识，于是这个对象就被标识为可到达对象。</p><p>清除阶段：垃圾回收器会对堆内存从头到尾进行线性遍历，如果发现有对象没有被标识为可到达对象，那么就将此对象占用的内存回收，并且将原来标记为可到达对象的标识清除，以便进行下一次垃圾回收操作。</p><p>优点：解决了循环引用问题</p><p>缺点：内存碎片化问题</p><p>内存碎片</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220319163559599-1442669422.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>那如何找到合适的块呢？我们可以采取下面三种分配策略</p><ul><li><code>First-fit</code>，找到大于等于 <code>size</code> 的块立即返回</li><li><code>Best-fit</code>，遍历整个空闲列表，返回大于等于 <code>size</code> 的最小分块</li><li><code>Worst-fit</code>，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 <code>size</code> 大小，并将该部分返回</li></ul><p><strong>标记整理法</strong>：与标记清除法理解一致，不同处在清除之前，会进行整理</p><p>优点：解决内存碎片化</p><p>缺点：性能消耗大，每次清除前，都要去整理内存</p><h4 id="_3-v8引擎的回收机制" tabindex="-1"><a class="header-anchor" href="#_3-v8引擎的回收机制"><span>3.V8引擎的回收机制</span></a></h4><p>Chrome 浏览器所使用的 V8 引擎采用的<strong>分代回收</strong>策略，将对象区分为<strong>临时对象</strong>（新生代）和<strong>持久对象</strong>（老生代）；多回收临时对象，少回收持久对象</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320223409481-985539086.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>新生代对象特点：</p><ul><li>通常把小的对象分配到新生代</li><li>新生代的垃圾回收比较频繁</li><li>通常存储容量在1~8M</li></ul><p>新生代-<code>Scavenge</code>算法：</p><p>该算法将新生代分为两部分，一部分叫做from（对象区域），另一部分叫做to（空闲区域），新加入的对象首先存放在from区域</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320222512252-618938289.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>from区域写满的时候，对from区域开始进行垃圾回收。首先对from区域的垃圾进行标记(红色代表标记为垃圾)</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320222532461-104056076.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>将存活的对象复制到to区域中，并且有序地排列起来，复制后的to区域就没有内存碎片了</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320222624767-871994632.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>清空from区域，from区域和to区域进行反转。from区域变为to区域，原来的to区域变成from区域</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320222844769-1929737231.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>特点：效率高，缺点是只能使用堆内存的一半，如果存储量过大效率会导致清理时间变长，效率低。所以经过两次回收后还存活的对象会晋升为老生代对象。</p><p>另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 <code>Scavenge</code> 回收后，空闲区将翻转成对象区域，继续进行对象内存的分配，若占比过大，将会影响后续内存分配。</p><p>老生代对象特点：</p><ul><li>对象占用空间大</li><li>对象存活时间长</li></ul><p>老生代-标记整理法</p><p><strong>何时执行垃圾回收</strong></p><p>由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿。</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320224732161-2073439953.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320224800732-1238024954.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="浏览器缓存机制" tabindex="-1"><a class="header-anchor" href="#浏览器缓存机制"><span>浏览器缓存机制</span></a></h2><h3 id="缓存概述" tabindex="-1"><a class="header-anchor" href="#缓存概述"><span>缓存概述</span></a></h3><h4 id="什么是缓存" tabindex="-1"><a class="header-anchor" href="#什么是缓存"><span>什么是缓存？</span></a></h4><p>缓存是一种<strong>保存资源副本</strong>并在<strong>下次请求直接使用该副本</strong>的技术。</p><h4 id="为什么使用缓存-作用" tabindex="-1"><a class="header-anchor" href="#为什么使用缓存-作用"><span>为什么使用缓存？作用</span></a></h4><p>网络请求速度会受到服务器的性能、网络的带宽、网络条件、以及网络链路的距离等的影响。</p><p><strong>缓存的作用</strong>：</p><ul><li>降低了对原始服务器的要求。缓存设备可以更快地响应用户，同时避免服务器过载的出现。</li><li>减少网络上冗余的数据传输，节省网络费用。</li><li>缓解了网络瓶颈的问题。不需要更多的带宽就能够更快地加载页面。</li><li>降低了距离时延，因为请求链路距离会更短，距离短传输速度会比较快。</li></ul><h3 id="缓存的位置" tabindex="-1"><a class="header-anchor" href="#缓存的位置"><span>缓存的位置</span></a></h3><p>浏览器缓存通过 HTTP/HTTPS 实现，存储位置有四种：</p><ul><li>Service Worker</li><li>Memory Cache（内存缓存）</li><li>Disk Cache（硬盘缓存）</li><li>Push Cache（推送缓存）</li></ul><p>以上缓存全部没有命中就会进行网络请求。</p><h4 id="service-worker" tabindex="-1"><a class="header-anchor" href="#service-worker"><span>Service Worker</span></a></h4><p>Service Worker 是运行在浏览器背后的独立线程，可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</p><h4 id="memory-cache" tabindex="-1"><a class="header-anchor" href="#memory-cache"><span>Memory Cache</span></a></h4><p>Memory Cache 是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据高效，但是缓存持续性很短。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。而且由于计算机中的内存比硬盘容量小得多，我们能够使用存储缓存的内存并不多。</p><p>内存缓存在缓存资源时并不关心返回资源的 HTTP 缓存头 Cache-Control，同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 Content-Type，CORS 等其他特征做校验。</p><h4 id="disk-cache" tabindex="-1"><a class="header-anchor" href="#disk-cache"><span>Disk Cache</span></a></h4><p>Disk Cache 是存储在硬盘中的缓存，读取速度比 Memory Cache 慢，但是存储量更大。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。</p><h4 id="push-cache" tabindex="-1"><a class="header-anchor" href="#push-cache"><span>Push Cache</span></a></h4><p>Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。<strong>它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂</strong>，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。</p><p><strong>浏览器什么时候会把缓存存储到内存中，什么时候存储到硬盘中呢？一般来说：</strong></p><ul><li>小文件优先存储到内存中，反之存储到硬盘中</li><li>使用频率高的缓存到硬盘中</li></ul><p>Disk Cache严格遵守HTTP缓存规则。</p><h3 id="缓存有效性" tabindex="-1"><a class="header-anchor" href="#缓存有效性"><span>缓存有效性</span></a></h3><h4 id="命中与未命中" tabindex="-1"><a class="header-anchor" href="#命中与未命中"><span>命中与未命中</span></a></h4><p>缓存无法保存Web的所有文档，即使有，文档也会发生变化，很多缓存也不能及时地进行更新。缓存无法为所有的请求提供服务。</p><p>当已有的副本为到达缓存的请求提供服务，称为<strong>缓存命中（cache hit）</strong></p><p>如果到达缓存的请求没有副本可用，而被转发给原始服务器，被称为<strong>缓存未命中（cache miss）</strong></p><h4 id="再验证" tabindex="-1"><a class="header-anchor" href="#再验证"><span>再验证</span></a></h4><p>原来的服务器内容可能会发生变化，缓存要对其检测，看看保存的副本是否还是服务器的最新副本，这个检测也被称为<strong>HTTP再验证</strong></p><p>再验证分为三种情况：</p><p>1.再验证命中</p><p>如果服务器对象未被修改，服务器会向客户端发送一个小的 HTTP 304 Not Modified 响应。</p><p>2.再验证未命中</p><p>如果服务器对象与已缓存副本不同，服务器向客户端发送一条普通的、带有完整内容的 HTTP 200 OK 响应。</p><p>3.对象被删除</p><p>如果服务器对象已经被删除了，服务器就回送一个 404 Not Found 响应，缓存也会将其副本删除</p><h4 id="区分响应应来自缓存还是服务器" tabindex="-1"><a class="header-anchor" href="#区分响应应来自缓存还是服务器"><span>区分响应应来自缓存还是服务器</span></a></h4><p>客户端可以通过三个响应头来区分是缓存还是服务器返回：</p><ul><li><strong>Via 首部</strong>。有些商业代理缓存会在 Via 首部附加一些额外信息来描述缓存中发生的情况。</li><li><strong>Date 首部</strong>。指的是服务器响应生成的时间。将响应中 Date 首部的值与当前时间进行比较，如果响应中的日期值比较早，通常就可以认为是来自缓存的响应。</li><li><strong>Age 首部</strong>。客户端也可以通过 Age 首部来检测缓存的响应，指的是代理服务器对于请求资源的已缓存时间, 单位为秒</li></ul><h3 id="缓存拓扑结构" tabindex="-1"><a class="header-anchor" href="#缓存拓扑结构"><span>缓存拓扑结构</span></a></h3><h4 id="私有缓存和公有缓存" tabindex="-1"><a class="header-anchor" href="#私有缓存和公有缓存"><span>私有缓存和公有缓存</span></a></h4><p>缓存可以是单个用户专用的，也可以是数千名用户共享的。 把缓存的服务范围进行分类，可以分为私有缓存与公有缓存。</p><p><strong>私有缓存</strong></p><p>私有缓存（private cache）也被称为专用缓存，包含了单个用户最常用的页面。 私有缓存不需要很大的处理能力或存储空间，这样它的成本就能比较低。 Web 浏览器中有内建的私有缓存——大多数浏览器都会将常用文档缓存在你个人电脑的磁盘和内存中，并且允许用户去配置缓存的大小和各种设置。还可以去看看浏览器的缓存中有些什么内容。</p><p><strong>公有缓存</strong></p><p><strong>公有缓存</strong>被称为<strong>缓存代理服务器（caching proxy server）</strong>，或者被称为<strong>代理缓存（proxy cache）</strong>，包含了一个群体的常用页面。代理缓存会从缓存服务器本地提供文档，或者代表用户与服务器进行联系。公有缓存会接受来自<strong>多个用户</strong>的访问，所以通过它可以更好地减少冗余流量。</p><p>代理缓存可以通过指定手工代理，或者通过代理自动配置文件，将你的浏览器配置为使用代理缓存。还可以通过使用拦截代理在不配置浏览器的情况下，强制 HTTP 请求经过缓存传输。</p><p><strong>层级结构和网状结构</strong></p><p>层次化的缓存结构和网状的缓存结构</p><h3 id="缓存的处理步骤" tabindex="-1"><a class="header-anchor" href="#缓存的处理步骤"><span>缓存的处理步骤</span></a></h3><ol><li>接受：从网络中读取抵达的请求报文</li><li>解析：对报文进行解析，提取出url和各种首部</li><li>查询：查询本地是否有缓存副本，如果没有，就请求上级缓存代理或者请求源服务器。完成后保存至本地。</li><li>新鲜度检测：查看本地一缓存的副本是否足够新鲜，如果不是，就像源服务器请求是否有更新</li><li>创建响应：缓存服务器重新构建响应首部</li><li>发送：将响应报文发送给客户端</li><li>日志：记录日志</li></ol><h3 id="缓存类型" tabindex="-1"><a class="header-anchor" href="#缓存类型"><span>缓存类型</span></a></h3><h4 id="强制缓存" tabindex="-1"><a class="header-anchor" href="#强制缓存"><span><strong>强制缓存</strong></span></a></h4><p>强制缓存是在浏览器加载资源的时候，先检查缓存时间是否过期，若未过期则直接从缓存中查找请求结果，如果缓存时间过期或不存在该缓存结果，则向服务端发起请求。</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-9d213cea6613d3ebdefed4ba1f58a43d_r.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>设置缓存时间（响应头字段）</strong></p><ul><li>Expires（HTTP/1.0）</li><li>Cache-Control（HTTP/1.1）</li></ul><h4 id="expires" tabindex="-1"><a class="header-anchor" href="#expires"><span>Expires</span></a></h4><p>HTTP/1.0 中使用响应头部字段 Expires 来设置缓存过期时间。客户端第一次请求时，服务端会在响应头部添加 Expires 字段。当浏览器再次发送请求时，先会对比当前时间和 Expires 对应的时间，如果当前时间早于 Expires 时间，那么直接使用缓存；反之，需要再次发送请求。</p><p>出现的问题：</p><ul><li>服务端和浏览器的时间可能不同，导致缓存过期时间出现偏差</li><li>客户端可以通过修改系统时间来继续使用缓存或提前使缓存失效</li></ul><h4 id="cache-control" tabindex="-1"><a class="header-anchor" href="#cache-control"><span>Cache-Control</span></a></h4><ul><li><code>no-cache</code>：表示使用协商缓存，即每次使用缓存前必须向服务端确认缓存资源是否更新；</li><li><code>no-store</code>：禁止浏览器以及所有中间缓存存储响应内容；</li><li><code>public</code>：公有缓存，表示可以被代理服务器缓存，可以被多个用户共享；</li><li><code>private</code>：私有缓存，不能被代理服务器缓存，不可以被多个用户共享；</li><li><code>max-age</code>：以秒为单位的数值，表示缓存的有效时间；</li><li><code>must-revalidate</code>：当缓存过期时，需要去服务端校验缓存的有效性。</li></ul><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-98a1ce2905ce1c0d1358a28b73b60f5b_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>此 Cache-Control 信息告诉浏览器该缓存为公有缓存，有效期 1 年。</p><p><strong>200 状态码一定是服务器返回的吗？</strong></p><p><strong>不是</strong>。命中强缓存的话，会直接从内存或者磁盘中读取资源，并返回一个200状态码，具体操作可以试试浏览器的前进后退键。</p><h4 id="协商缓存" tabindex="-1"><a class="header-anchor" href="#协商缓存"><span>协商缓存</span></a></h4><p>协商缓存不指定缓存的有效时间，而是在请求时直接发送资源标识到服务端确认缓存是否需要更新，如果请求响应返回的 HTTP 状态为 304，则表示缓存仍然有效；否则返回状态码 200 、最新的资源和最新的资源标识。</p><p>控制缓存的难题就从浏览器端转移到了服务端</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-6c0b82ec07fcc384fa011b5a04f4e384_r.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>资源标识（在 Response Header 中）有两种</strong></p><ul><li>Last-Modified：资源的最后修改时间</li><li>Etag：资源的唯一标识（一个字符串）</li></ul><h4 id="last-modified-和-if-modified-since" tabindex="-1"><a class="header-anchor" href="#last-modified-和-if-modified-since"><span>Last-Modified 和 If-Modified-Since</span></a></h4><p>服务端通过响应头部字段 Last-Modified 和请求头部字段 If-Modified-Since 比对双方资源的修改时间，来确定缓存是否需要更新。具体工作流程如下：</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-e7c5b4ea204be53364f72ef03fef6fbd_r.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ol><li>浏览器第一次请求资源，服务端在返回资源的响应头中加入 Last-Modified 字段，表示这个资源在服务端上的最近修改时间；</li><li>当浏览器再次向服务端请求该资源时，请求头部带上之前服务端返回的 Last-Modified，这个请求头叫 If-Modified-Since；</li><li>服务端再次收到请求，根据 If-Modified-Since 的值，判断相关资源是否有变化，如果没有，则返回 304 Not Modified，浏览器使用资源缓存值；否则返回资源内容，且更新 Last-Modified 响应头内容。</li></ol><p>这种方式虽然能判断缓存是否失效，但也存在三个问题：</p><ol><li>精度问题：Last-Modified 的时间精度为秒，如果在 1 秒内发生修改，那么缓存判断会失效</li><li>准度问题：如果一个文件被修改后又被还原，内容没有发生变化，却仍然需要重新请求</li><li>服务器问题：某些服务器不能精确的得到文件的最后修改时间</li></ol><h4 id="etag-和-if-none-match" tabindex="-1"><a class="header-anchor" href="#etag-和-if-none-match"><span>ETag 和 If-None-Match</span></a></h4><p>为了解决精度问题和准度问题，HTTP 提供了另一种依赖于文件哈希值的精确判断缓存的方式：响应头部字段 ETag 和请求头部字段 If-None-Match。具体工作流程如下：</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-3e1da5789e1743643ee8c0ed8487660e_r.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ol><li>浏览器第一次请求资源，服务端在返响应头中加入 Etag 字段，Etag 字段值为该资源的哈希值；</li><li>当浏览器再次跟服务端请求这个资源时，在请求头上加上 If-None-Match，值为之前响应头部字段 ETag 的值；</li><li>服务端再次收到请求，将请求头 If-None-Match 字段的值和响应资源的哈希值进行比对，如果两个值相同，则说明资源没有变化，返回 304 Not Modified；否则就正常返回资源内容，无论是否发生变化，都会将计算出的哈希值放入响应头部的 ETag 字段中。</li></ol><p>缺点：</p><ul><li>计算成本。对于大文件而言，读取完整的文件内容生成哈希值开销较大；只读取文件部分内容，又容易判断出错。</li><li>计算误差。不同服务端可能会采用不同的哈希值计算方式。所以同一个资源在两台服务端产生的 Etag 可能是不相同的。对于使用服务器集群来处理请求的网站来说，使用 Etag 的缓存命中率会有所降低。</li></ul><p>两者中会优先使用 Etag：</p><ul><li>Last-Modified 只能精确到秒级</li><li>如果资源被重复生成，而内容不变，Etag 更加精准</li></ul><p><strong>缓存的优先级：</strong></p><ul><li><p>强制缓存的优先级高于协商缓存:</p></li><li><ul><li>强制缓存中：cache-control 的 max-age 优先级高于 Expires</li><li>协商缓存中：Etag 优先级比 Last-Modified 高。</li></ul></li><li><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/流程图-导出.png" alt="流程图-导出" tabindex="0" loading="lazy"><figcaption>流程图-导出</figcaption></figure></li></ul><h4 id="用户行为" tabindex="-1"><a class="header-anchor" href="#用户行为"><span>用户行为</span></a></h4><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-73241506477c2bb5b47cb99f93f28caa_720w.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="禁用缓存" tabindex="-1"><a class="header-anchor" href="#禁用缓存"><span>禁用缓存</span></a></h4><p>服务器禁用缓存：</p><ul><li>Cache-Control: max-age=0, must-revalidate</li><li>Cache-Control: no-cache</li><li>Cache-Control: no-store</li></ul><p>浏览器禁用缓存：</p><ul><li>改变 url，加上<code>?xi=xixi</code></li><li>设置请求 header</li></ul><h2 id="js执行上下文与执行栈" tabindex="-1"><a class="header-anchor" href="#js执行上下文与执行栈"><span>JS执行上下文与执行栈</span></a></h2><h3 id="概述-1" tabindex="-1"><a class="header-anchor" href="#概述-1"><span>概述</span></a></h3><h4 id="什么是执行上下文" tabindex="-1"><a class="header-anchor" href="#什么是执行上下文"><span>什么是执行上下文？</span></a></h4><p>执行上下文就是当前JS代码被解析和运行时所在的<strong>环境</strong>的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。</p><p>声明周期：创建-执行-销毁</p><h4 id="三种全局上写下文" tabindex="-1"><a class="header-anchor" href="#三种全局上写下文"><span>三种全局上写下文</span></a></h4><ol><li>全局执行上下文</li><li>函数执行上下文</li><li>eval 执行上下文</li></ol><h3 id="详细功能" tabindex="-1"><a class="header-anchor" href="#详细功能"><span>详细功能</span></a></h3><h4 id="全局执行上下文" tabindex="-1"><a class="header-anchor" href="#全局执行上下文"><span>全局执行上下文</span></a></h4><p>全局执行上下文是在全局的代码执行前,JS引擎自动进行的工作</p><p>第一步：将<code>window对象</code>指定为全局执行上下文对象</p><p>第二步：对在全局作用域中的数据进行<strong>预处理</strong></p><ol><li>收集所有在<strong>全局作用域</strong>中使用<strong>var</strong>关键字定义的变量,将值赋值为<code>undefined</code>,并添加成为<code>全局执行上下文对象window</code>的属性</li><li>收集所有在全局作用域中使用function关键字申明的函数,添加成为<code>全局执行上下文对象window</code>的方法</li><li>将上下文对象指向全局执行上下文对象, 即: this = window</li></ol><p>第三步：开始执行全局代码,变量赋值的正常赋值,语句、表达式等执行的执行</p><h4 id="局部-函数-执行上下文" tabindex="-1"><a class="header-anchor" href="#局部-函数-执行上下文"><span>局部(函数)执行上下文</span></a></h4><p>在函数调用之后，执行代码之前创建函数执行上下文</p><p>第一步：对函数内部中的变量、参数进行预处理</p><ol><li>形参变量会被赋值成实参的值,然后添加成为函数执行上下文对象的属性</li><li>arguments对象被赋值由实参组成的伪数组,然后添加成为函数执行上下文对象的属性</li><li><code>var</code>关键字申明的变量与<code>function</code>关键字申明的函数,与全局执行上下文状况类似,但是被限制在了函数作用域中</li></ol><p>第二步：上下文对象根据调用函数的对象,动态变化 即: this是动态变化的</p><p>第三步：执行函数体代码</p><h4 id="执行上下文创建" tabindex="-1"><a class="header-anchor" href="#执行上下文创建"><span>执行上下文创建</span></a></h4><p>分为创建阶段执行阶段</p><p>创建过程：主要负责三件事</p><ol><li>确定this</li><li>创建词法环境组件（LexicalEnvironment）</li><li>创建变量环境组件（VariableEnvironment）</li></ol><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>ExecutionContext <span class="token operator">=</span> <span class="token punctuation">{</span>  
    <span class="token comment">// 确定this的值</span>
    ThisBinding <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token keyword">this</span> value<span class="token operator">&gt;</span><span class="token punctuation">,</span>
    <span class="token comment">// 创建词法环境组件</span>
    LexicalEnvironment <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 创建变量环境组件</span>
    VariableEnvironment <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>确定this</strong></p><p>1.在全局执行上下文中，this总是指向全局对象，例如浏览器环境下this指向window对象。</p><p>2.而在函数执行上下文中，this的值取决于函数的调用方式，如果被一个对象调用，那么this指向这个对象。否则this一般指向全局对象window或者undefined（严格模式）。</p><p><strong>词法环境组件</strong></p><p>1.词法环境是一个包含标识符变量映射的结构，这里的标识符表示变量/函数的名称，变量是对实际对象【包括函数类型对象】或原始值的引用。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">444</span> 
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// 标识符a 映射 Number类型的值444</span>
<span class="token comment">// 标识符b 映射 对象所在堆内存的地址值</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2.词法环境由<strong>环境记录</strong>与<strong>对外部环境引入记录</strong>两个部分组成。</p><p>3.其中环境记录用于存储当前环境中的变量和函数声明的实际位置；外部环境引入记录很好理解，它用于保存自身环境可以访问的其它外部环境(作用域链)</p><p>4.词法环境分为全局词法环境与函数词法环境两种。</p><p><strong>(1)全局词法环境</strong>：</p><p>对外部环境的引入记录为null，因为它本身就是最外层环境，除此之外它还记录了当前环境下的所有属性、方法位置</p><p><strong>(2)函数词法环境组件：</strong></p><p>包含了用户在函数中定义的所有属性方法外，还包含了一个arguments对象。函数词法环境的外部环境引入可以是全局环境，也可以是其它函数环境</p><p><strong>变量环境组件</strong></p><p>变量环境可以说也是词法环境，它具备词法环境所有属性，一样有环境记录与外部环境引入，在ES6中唯一的区别在于词法环境用于存储函数声明与let const声明的变量，而变量环境仅仅存储var声明的变量。</p><p>伪代码形式描述：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">//全局执行上下文</span>
GlobalExectionContext <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// this绑定为全局对象</span>
    <span class="token literal-property property">ThisBinding</span><span class="token operator">:</span> <span class="token operator">&lt;</span>Global Object<span class="token operator">&gt;</span><span class="token punctuation">,</span>
    <span class="token comment">// 词法环境</span>
    <span class="token literal-property property">LexicalEnvironment</span><span class="token operator">:</span> <span class="token punctuation">{</span>  
        <span class="token comment">//环境记录</span>
      <span class="token literal-property property">EnvironmentRecord</span><span class="token operator">:</span> <span class="token punctuation">{</span>  
        <span class="token literal-property property">Type</span><span class="token operator">:</span> <span class="token string">&quot;Object&quot;</span><span class="token punctuation">,</span>  <span class="token comment">// 对象环境记录</span>
        <span class="token comment">// 标识符绑定在这里 let const创建的变量a b在这</span>
        <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token operator">&lt;</span> uninitialized <span class="token operator">&gt;</span><span class="token punctuation">,</span>  
        <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token operator">&lt;</span> uninitialized <span class="token operator">&gt;</span><span class="token punctuation">,</span>  
        <span class="token literal-property property">multiply</span><span class="token operator">:</span> <span class="token operator">&lt;</span> func <span class="token operator">&gt;</span>  
      <span class="token punctuation">}</span>
      <span class="token comment">// 全局环境外部环境引入为null</span>
      <span class="token literal-property property">outer</span><span class="token operator">:</span> <span class="token operator">&lt;</span><span class="token keyword">null</span><span class="token operator">&gt;</span>  
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  
    <span class="token literal-property property">VariableEnvironment</span><span class="token operator">:</span> <span class="token punctuation">{</span>  
      <span class="token literal-property property">EnvironmentRecord</span><span class="token operator">:</span> <span class="token punctuation">{</span>  
        <span class="token literal-property property">Type</span><span class="token operator">:</span> <span class="token string">&quot;Object&quot;</span><span class="token punctuation">,</span>  <span class="token comment">// 对象环境记录</span>
        <span class="token comment">// 标识符绑定在这里  var创建的c在这</span>
        <span class="token literal-property property">c</span><span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>  
      <span class="token punctuation">}</span>
      <span class="token comment">// 全局环境外部环境引入为null</span>
      <span class="token literal-property property">outer</span><span class="token operator">:</span> <span class="token operator">&lt;</span><span class="token keyword">null</span><span class="token operator">&gt;</span>  
    <span class="token punctuation">}</span>  
  <span class="token punctuation">}</span>

  <span class="token comment">// 函数执行上下文</span>
  FunctionExectionContext <span class="token operator">=</span> <span class="token punctuation">{</span>
     <span class="token comment">//由于函数是默认调用 this绑定同样是全局对象</span>
    <span class="token literal-property property">ThisBinding</span><span class="token operator">:</span> <span class="token operator">&lt;</span>Global Object<span class="token operator">&gt;</span><span class="token punctuation">,</span>
    <span class="token comment">// 词法环境</span>
    <span class="token literal-property property">LexicalEnvironment</span><span class="token operator">:</span> <span class="token punctuation">{</span>  
      <span class="token literal-property property">EnvironmentRecord</span><span class="token operator">:</span> <span class="token punctuation">{</span>  
        <span class="token literal-property property">Type</span><span class="token operator">:</span> <span class="token string">&quot;Declarative&quot;</span><span class="token punctuation">,</span>  <span class="token comment">// 声明性环境记录</span>
        <span class="token comment">// 标识符绑定在这里  arguments对象在这</span>
        <span class="token literal-property property">Arguments</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token literal-property property">length</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  
      <span class="token punctuation">}</span><span class="token punctuation">,</span>  
      <span class="token comment">// 外部环境引入记录为&lt;/Global&gt;</span>
      <span class="token literal-property property">outer</span><span class="token operator">:</span> <span class="token operator">&lt;</span>GlobalEnvironment<span class="token operator">&gt;</span>  
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  
    <span class="token literal-property property">VariableEnvironment</span><span class="token operator">:</span> <span class="token punctuation">{</span>  
      <span class="token literal-property property">EnvironmentRecord</span><span class="token operator">:</span> <span class="token punctuation">{</span>  
        <span class="token literal-property property">Type</span><span class="token operator">:</span> <span class="token string">&quot;Declarative&quot;</span><span class="token punctuation">,</span>  <span class="token comment">// 声明性环境记录</span>
        <span class="token comment">// 标识符绑定在这里  var创建的g在这</span>
        <span class="token literal-property property">g</span><span class="token operator">:</span> <span class="token keyword">undefined</span>  
      <span class="token punctuation">}</span><span class="token punctuation">,</span>  
      <span class="token comment">// 外部环境引入记录为&lt;/Global&gt;</span>
      <span class="token literal-property property">outer</span><span class="token operator">:</span> <span class="token operator">&lt;</span>GlobalEnvironment<span class="token operator">&gt;</span>  
    <span class="token punctuation">}</span>  
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="执行上下文栈" tabindex="-1"><a class="header-anchor" href="#执行上下文栈"><span>执行上下文栈</span></a></h4><p>首先JS代码执行前会先创建全局执行上下文，执行栈用于存放所有的执行下上下文，全局执行上下文先入栈，遇到函数调用创建函数执行上下文，压入栈顶，先执行栈顶部的上下文，从上往下依次执行，最后执行全局上下文</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/执行上下文.png" alt="执行上下文" tabindex="0" loading="lazy"><figcaption>执行上下文</figcaption></figure>`,286),p=[t];function l(o,r){return n(),s("div",null,p)}const g=a(i,[["render",l],["__file","JavaScript与浏览器原理.html.vue"]]),m=JSON.parse('{"path":"/base/JavaScript/JavaScript%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86.html","title":"JavaScript与浏览器原理","lang":"zh-CN","frontmatter":{"description":"JavaScript与浏览器原理 浏览器模型 script元素 ####工作原理 网页加载流程： 浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。 解析过程中，浏览器发现<script>元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。 如果<script>元素引用了外部脚本，就下载该脚本再执行，...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/Blog/base/JavaScript/JavaScript%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"取名花光钱"}],["meta",{"property":"og:title","content":"JavaScript与浏览器原理"}],["meta",{"property":"og:description","content":"JavaScript与浏览器原理 浏览器模型 script元素 ####工作原理 网页加载流程： 浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。 解析过程中，浏览器发现<script>元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。 如果<script>元素引用了外部脚本，就下载该脚本再执行，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/html%E8%A7%A3%E6%9E%90.jpeg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"取名花光钱"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JavaScript与浏览器原理\\",\\"image\\":[\\"https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/html%E8%A7%A3%E6%9E%90.jpeg\\",\\"https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/ltw003.png\\",\\"https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-858bcd85eb943a853cdbaf3ba7227985_720w.webp\\",\\"https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/ltw001.png\\",\\"https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/Snipaste_2022-11-01_21-33-21.png\\",\\"https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220319163559599-1442669422.webp\\",\\"https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320223409481-985539086.png\\",\\"https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320222512252-618938289.png\\",\\"https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320222532461-104056076.png\\",\\"https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320222624767-871994632.png\\",\\"https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320222844769-1929737231.png\\",\\"https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320224732161-2073439953.png\\",\\"https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320224800732-1238024954.png\\",\\"https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-9d213cea6613d3ebdefed4ba1f58a43d_r.jpg\\",\\"https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-98a1ce2905ce1c0d1358a28b73b60f5b_720w.png\\",\\"https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-6c0b82ec07fcc384fa011b5a04f4e384_r.jpg\\",\\"https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-e7c5b4ea204be53364f72ef03fef6fbd_r.jpg\\",\\"https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-3e1da5789e1743643ee8c0ed8487660e_r.jpg\\",\\"https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/%E6%B5%81%E7%A8%8B%E5%9B%BE-%E5%AF%BC%E5%87%BA.png\\",\\"https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-73241506477c2bb5b47cb99f93f28caa_720w.webp\\",\\"https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87.png\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"取名花光钱\\",\\"url\\":\\"https://molimamcc.github.io/Blog/\\"}]}"]]},"headers":[{"level":2,"title":"浏览器模型","slug":"浏览器模型","link":"#浏览器模型","children":[{"level":3,"title":"script元素","slug":"script元素","link":"#script元素","children":[]},{"level":3,"title":"浏览器的组成","slug":"浏览器的组成","link":"#浏览器的组成","children":[]}]},{"level":2,"title":"JavaScript运行机制","slug":"javascript运行机制","link":"#javascript运行机制","children":[{"level":3,"title":"浏览器的组成","slug":"浏览器的组成-1","link":"#浏览器的组成-1","children":[]},{"level":3,"title":"事件循环","slug":"事件循环","link":"#事件循环","children":[]},{"level":3,"title":"垃圾回收机制","slug":"垃圾回收机制","link":"#垃圾回收机制","children":[]}]},{"level":2,"title":"浏览器缓存机制","slug":"浏览器缓存机制","link":"#浏览器缓存机制","children":[{"level":3,"title":"缓存概述","slug":"缓存概述","link":"#缓存概述","children":[]},{"level":3,"title":"缓存的位置","slug":"缓存的位置","link":"#缓存的位置","children":[]},{"level":3,"title":"缓存有效性","slug":"缓存有效性","link":"#缓存有效性","children":[]},{"level":3,"title":"缓存拓扑结构","slug":"缓存拓扑结构","link":"#缓存拓扑结构","children":[]},{"level":3,"title":"缓存的处理步骤","slug":"缓存的处理步骤","link":"#缓存的处理步骤","children":[]},{"level":3,"title":"缓存类型","slug":"缓存类型","link":"#缓存类型","children":[]}]},{"level":2,"title":"JS执行上下文与执行栈","slug":"js执行上下文与执行栈","link":"#js执行上下文与执行栈","children":[{"level":3,"title":"概述","slug":"概述-1","link":"#概述-1","children":[]},{"level":3,"title":"详细功能","slug":"详细功能","link":"#详细功能","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":32.84,"words":9852},"filePathRelative":"base/JavaScript/JavaScript与浏览器原理.md","excerpt":"\\n<h2>浏览器模型</h2>\\n<h3>script元素</h3>\\n<p>####工作原理</p>\\n<p><strong>网页加载流程</strong>：</p>\\n<ol>\\n<li>浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。</li>\\n<li>解析过程中，浏览器发现<code>&lt;script&gt;</code>元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。</li>\\n<li>如果<code>&lt;script&gt;</code>元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。</li>\\n<li>JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页。</li>\\n</ol>","autoDesc":true}');export{g as comp,m as data};
