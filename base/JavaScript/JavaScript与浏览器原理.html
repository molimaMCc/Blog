<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.8" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.31" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://mister-hope.github.io/Blog/base/JavaScript/JavaScript%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86.html"><meta property="og:site_name" content="取名花光钱"><meta property="og:title" content="JavaScript与浏览器原理"><meta property="og:description" content="JavaScript与浏览器原理 浏览器模型 script元素 ####工作原理 网页加载流程： 浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。 解析过程中，浏览器发现<script>元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。 如果<script>元素引用了外部脚本，就下载该脚本再执行，..."><meta property="og:type" content="article"><meta property="og:image" content="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/html%E8%A7%A3%E6%9E%90.jpeg"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="取名花光钱"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"JavaScript与浏览器原理","image":["https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/html%E8%A7%A3%E6%9E%90.jpeg","https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/ltw003.png","https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-858bcd85eb943a853cdbaf3ba7227985_720w.webp","https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/ltw001.png","https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/Snipaste_2022-11-01_21-33-21.png","https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220319163559599-1442669422.webp","https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320223409481-985539086.png","https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320222512252-618938289.png","https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320222532461-104056076.png","https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320222624767-871994632.png","https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320222844769-1929737231.png","https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320224732161-2073439953.png","https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320224800732-1238024954.png","https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-9d213cea6613d3ebdefed4ba1f58a43d_r.jpg","https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-98a1ce2905ce1c0d1358a28b73b60f5b_720w.png","https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-6c0b82ec07fcc384fa011b5a04f4e384_r.jpg","https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-e7c5b4ea204be53364f72ef03fef6fbd_r.jpg","https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-3e1da5789e1743643ee8c0ed8487660e_r.jpg","https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/%E6%B5%81%E7%A8%8B%E5%9B%BE-%E5%AF%BC%E5%87%BA.png","https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-73241506477c2bb5b47cb99f93f28caa_720w.webp","https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87.png"],"dateModified":null,"author":[{"@type":"Person","name":"取名花光钱","url":"https://molimamcc.github.io/Blog/"}]}</script><title>JavaScript与浏览器原理 | 取名花光钱</title><meta name="description" content="JavaScript与浏览器原理 浏览器模型 script元素 ####工作原理 网页加载流程： 浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。 解析过程中，浏览器发现<script>元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。 如果<script>元素引用了外部脚本，就下载该脚本再执行，...">
    <link rel="preload" href="/Blog/assets/style-BC3nh59h.css" as="style"><link rel="stylesheet" href="/Blog/assets/style-BC3nh59h.css">
    <link rel="modulepreload" href="/Blog/assets/app-otQn-0y1.js"><link rel="modulepreload" href="/Blog/assets/JavaScript与浏览器原理.html-DrIlvcOO.js"><link rel="modulepreload" href="/Blog/assets/plugin-vue_export-helper-DlAUqK2U.js">
    <link rel="prefetch" href="/Blog/assets/intro.html-D_XL3KvO.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-CxzZSlu6.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-CeWseMk6.js" as="script"><link rel="prefetch" href="/Blog/assets/CSS.html-BzhdN0ot.js" as="script"><link rel="prefetch" href="/Blog/assets/Layout.html-DBkAaTfE.js" as="script"><link rel="prefetch" href="/Blog/assets/AJAX.html-bEBRbmC5.js" as="script"><link rel="prefetch" href="/Blog/assets/HTML5.html-Bt-yJ2cl.js" as="script"><link rel="prefetch" href="/Blog/assets/HTMLBase.html-khFgOgQP.js" as="script"><link rel="prefetch" href="/Blog/assets/ES6.html-DLfgf-fJ.js" as="script"><link rel="prefetch" href="/Blog/assets/JavaScript.html-B2mP23F-.js" as="script"><link rel="prefetch" href="/Blog/assets/Nodejs.html-BI15Pt6Q.js" as="script"><link rel="prefetch" href="/Blog/assets/TypeScript.html-B1yomQ2M.js" as="script"><link rel="prefetch" href="/Blog/assets/vue3.html-Cjn4Wcw4.js" as="script"><link rel="prefetch" href="/Blog/assets/DIFF算法.html-DquHPjx2.js" as="script"><link rel="prefetch" href="/Blog/assets/vue响应式.html-g5wg-6rl.js" as="script"><link rel="prefetch" href="/Blog/assets/pinia.html-hn5otXi3.js" as="script"><link rel="prefetch" href="/Blog/assets/vueRouter.html-CeQYLJfE.js" as="script"><link rel="prefetch" href="/Blog/assets/git.html-DHFo1vPz.js" as="script"><link rel="prefetch" href="/Blog/assets/webpack.html-BYbxqrkf.js" as="script"><link rel="prefetch" href="/Blog/assets/404.html-CYrnEfUR.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-B9_7O5nk.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-Bj6OZVph.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-CLiRGTj9.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-BIDUxp-4.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-DxlCq3z1.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-Cvt9QOvE.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-OuhA4CCT.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-D6KUliww.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-BXn3KVRA.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-DsuJjHOX.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-BU7YBFLh.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-CbT44jpl.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-CkxtjZBs.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-DlUhP1c7.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-CKbf1xCR.js" as="script"><link rel="prefetch" href="/Blog/assets/giscus-7BMGhbDA.js" as="script"><link rel="prefetch" href="/Blog/assets/photoswipe.esm-SzV8tJDW.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="route-link vp-brand" href="/Blog/"><img class="vp-nav-logo" src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/%E5%AE%A0%E7%89%A9-17113498598171.svg" alt><!----><span class="vp-site-name hide-in-pad">取名花光钱</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/Blog/" aria-label="首页"><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span>首页<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/Blog/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" aria-label="网络协议"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>网络协议<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="前端基础"><span class="title"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>前端基础</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>HTML</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a class="route-link nav-link" href="/Blog/base/HTML5/HTMLBase.html" aria-label="HTMLBASE"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>HTMLBASE<!----></a></li><li class="dropdown-subitem"><a class="route-link nav-link" href="/Blog/base/HTML5/HTML5.html" aria-label="HTML5"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>HTML5<!----></a></li><li class="dropdown-subitem"><a class="route-link nav-link" href="/Blog/base/HTML5/AJAX.html" aria-label="AJAX"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>AJAX<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>CSS</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a class="route-link nav-link" href="/Blog/base/CSS3/Layout.html" aria-label="CSSLayout"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>CSSLayout<!----></a></li><li class="dropdown-subitem"><a class="route-link nav-link" href="/Blog/base/CSS3/CSS.html" aria-label="CSS"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>CSS<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>JavaScript</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a class="route-link nav-link" href="/Blog/base/JavaScript/JavaScript.html" aria-label="JavaScript"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>JavaScript<!----></a></li><li class="dropdown-subitem"><a class="route-link nav-link" href="/Blog/base/JavaScript/ES6.html" aria-label="ES6"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>ES6<!----></a></li><li class="dropdown-subitem"><a class="route-link nav-link active" href="/Blog/base/JavaScript/JavaScript%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86.html" aria-label="Browse"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>Browse<!----></a></li><li class="dropdown-subitem"><a class="route-link nav-link" href="/Blog/base/JavaScript/TypeScript.html" aria-label="TypeScript"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>TypeScript<!----></a></li><li class="dropdown-subitem"><a class="route-link nav-link" href="/Blog/base/JavaScript/Nodejs.html" aria-label="NodeJs"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>NodeJs<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="Vue"><span class="title"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>Vue</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Vue3</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a class="route-link nav-link" href="/Blog/Vue/vue3/vue3.html" aria-label="Vue3"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>Vue3<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>工具</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a class="route-link nav-link" href="/Blog/Vue/%E5%B7%A5%E5%85%B7/pinia.html" aria-label="pinia"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>pinia<!----></a></li><li class="dropdown-subitem"><a class="route-link nav-link" href="/Blog/Vue/%E5%B7%A5%E5%85%B7/vueRouter.html" aria-label="vueRouter"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>vueRouter<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Vue源码</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a class="route-link nav-link" href="/Blog/Vue/Vue%E6%BA%90%E7%A0%81/DIFF%E7%AE%97%E6%B3%95.html" aria-label="DIFF算法"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>DIFF算法<!----></a></li><li class="dropdown-subitem"><a class="route-link nav-link" href="/Blog/Vue/Vue%E6%BA%90%E7%A0%81/vue%E5%93%8D%E5%BA%94%E5%BC%8F.html" aria-label="响应式原理"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>响应式原理<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="构建工具"><span class="title"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>构建工具</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>教程</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a class="route-link nav-link" href="/Blog/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/%E6%95%99%E7%A8%8B/webpack.html" aria-label="Webpack"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>Webpack<!----></a></li><li class="dropdown-subitem"><a class="route-link nav-link" href="/Blog/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/%E6%95%99%E7%A8%8B/git.html" aria-label="Git"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>Git<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="思维导图"><span class="title"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>思维导图</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="https://boardmix.cn/app/share/CAE.CP6tnwwgASoQrhHPiNKjN6G4H-15NzxZgDAGQAE/lgxjs7" rel="noopener noreferrer" target="_blank" aria-label="数组与字符串" class="nav-link"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>数组与字符串<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></li><li class="dropdown-item"><a href="https://boardmix.cn/app/share/CAE.CP6tnwwgASoQ6vK6n-yZX1vnbcpnBZnDbDAGQAE/lgxjs7" rel="noopener noreferrer" target="_blank" aria-label="DOM与BOM" class="nav-link"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>DOM与BOM<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></li><li class="dropdown-item"><a href="https://boardmix.cn/app/share/CAE.CP6tnwwgASoQ6vK6n-yZX1vnbcpnBZnDbDAGQAE/lgxjs7" rel="noopener noreferrer" target="_blank" aria-label="Math内置对象" class="nav-link"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>Math内置对象<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></li></ul></button></div></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item vp-repo"><a class="vp-repo-link" href="https://github.com/vuepress-theme-hope/vuepress-theme-hope" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">HTML5</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">CSS3</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><!----><span class="vp-sidebar-title">JavaScript</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/Blog/base/JavaScript/JavaScript.html" aria-label="JavaScript"><!---->JavaScript<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/Blog/base/JavaScript/ES6.html" aria-label="ES6"><!---->ES6<!----></a></li><li><a class="route-link nav-link active vp-sidebar-link vp-sidebar-page active" href="/Blog/base/JavaScript/JavaScript%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86.html" aria-label="JavaScript与浏览器原理"><!---->JavaScript与浏览器原理<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/Blog/base/JavaScript/TypeScript.html" aria-label="TypeScript"><!---->TypeScript<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/Blog/base/JavaScript/Nodejs.html" aria-label="Node.js"><!---->Node.js<!----></a></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->JavaScript与浏览器原理</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://molimamcc.github.io/Blog/" target="_blank" rel="noopener noreferrer">取名花光钱</a></span><span property="author" content="取名花光钱"></span></span><!----><!----><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 33 分钟</span><meta property="timeRequired" content="PT33M"></span><!----><!----></div><hr></div><div class="vp-toc-placeholder"><aside id="toc"><!--[--><!----><!--]--><div class="vp-toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/Blog/#浏览器模型">浏览器模型</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/Blog/#script元素">script元素</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/Blog/#浏览器的组成">浏览器的组成</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/Blog/#javascript运行机制">JavaScript运行机制</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/Blog/#浏览器的组成-1">浏览器的组成</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/Blog/#事件循环">事件循环</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/Blog/#垃圾回收机制">垃圾回收机制</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/Blog/#浏览器缓存机制">浏览器缓存机制</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/Blog/#缓存概述">缓存概述</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/Blog/#缓存的位置">缓存的位置</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/Blog/#缓存有效性">缓存有效性</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/Blog/#缓存拓扑结构">缓存拓扑结构</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/Blog/#缓存的处理步骤">缓存的处理步骤</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/Blog/#缓存类型">缓存类型</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/Blog/#js执行上下文与执行栈">JS执行上下文与执行栈</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/Blog/#概述-1">概述</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/Blog/#详细功能">详细功能</a></li><!----><!--]--></ul></li><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><h1 id="javascript与浏览器原理" tabindex="-1"><a class="header-anchor" href="#javascript与浏览器原理"><span>JavaScript与浏览器原理</span></a></h1><h2 id="浏览器模型" tabindex="-1"><a class="header-anchor" href="#浏览器模型"><span>浏览器模型</span></a></h2><h3 id="script元素" tabindex="-1"><a class="header-anchor" href="#script元素"><span>script元素</span></a></h3><p>####工作原理</p><p><strong>网页加载流程</strong>：</p><ol><li>浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。</li><li>解析过程中，浏览器发现<code>&lt;script&gt;</code>元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。</li><li>如果<code>&lt;script&gt;</code>元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。</li><li>JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页。</li></ol><p>造成的问题：</p><p>由于<code>js</code>脚本加载时间过长，浏览器会一直等待脚本下载完成，造成网页长时间未响应，浏览器呈现假死状态，这种称为**“阻塞效应”**</p><p>解决方案:</p><p>​ <code>DOMContentLoaded</code>事件回调函数，<code>DOMContentLoaded</code>事件只有在 DOM 结构生成之后才会触发</p><p>​ <code>script</code>标签的<code>onload</code>属性，当<code>&lt;script&gt;</code>标签指定的外部脚本文件下载和解析完成，会触发一个<code>load</code>事件，可以把所需执行的代码，放在这个事件的回调函数里面。</p><p><em><strong>但是，如果将脚本放在页面底部，就可以完全按照正常的方式写，上面两种方式都不需要。</strong></em></p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/html解析.jpeg" alt="html解析" tabindex="0" loading="lazy"><figcaption>html解析</figcaption></figure><p>解决“阻塞效应”</p><h4 id="defer" tabindex="-1"><a class="header-anchor" href="#defer"><span>defer</span></a></h4><p><code>defer</code>属性的运行流程如下。</p><ol><li>浏览器开始解析 HTML 网页。</li><li>解析过程中，发现带有<code>defer</code>属性的<code>&lt;script&gt;</code>元素。</li><li>浏览器继续往下解析 HTML 网页，同时并行下载<code>&lt;script&gt;</code>元素加载的外部脚本。</li><li>浏览器完成解析 HTML 网页，此时再回过头执行已经下载完成的脚本。</li></ol><p>有了<code>defer</code>属性，浏览器下载脚本文件的时候，不会阻塞页面渲染。下载的脚本文件在<code>DOMContentLoaded</code>事件触发前执行（即刚刚读取完<code>&lt;/html&gt;</code>标签），而且可以保证执行顺序就是它们在页面上出现的顺序。</p><h4 id="async" tabindex="-1"><a class="header-anchor" href="#async"><span>async</span></a></h4><p><code>async</code>属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。</p><ol><li>浏览器开始解析 HTML 网页。</li><li>解析过程中，发现带有<code>async</code>属性的<code>script</code>标签。</li><li>浏览器继续往下解析 HTML 网页，同时并行下载<code>&lt;script&gt;</code>标签中的外部脚本。</li><li>脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本。</li><li>脚本执行完毕，浏览器恢复解析 HTML 网页。</li></ol><h4 id="加载使用的协议" tabindex="-1"><a class="header-anchor" href="#加载使用的协议"><span>加载使用的协议</span></a></h4><p>如果不指定协议，浏览器默认采用 HTTP 协议下载</p><p>如果要采用 HTTPS 协议下载，必需写明。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;https://example.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是有时我们会希望，根据页面本身的协议来决定加载协议，这时可以采用下面的写法。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;//example.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="浏览器的组成" tabindex="-1"><a class="header-anchor" href="#浏览器的组成"><span>浏览器的组成</span></a></h3><ol><li><p>用户界面:</p><p>用户界面主要包括：地址栏，后退/前进按钮，书签目录等；（除了从服务器请求到的网页窗口）</p></li><li><p>浏览器引擎：</p><p>用来查询及操作渲染引擎的接口；</p></li><li><p>渲染引擎：</p><p>用来显示请求的html内容；（包括样式，图片，js）</p></li><li><p>网络：</p><p>主要是来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作；</p></li><li><p>UI后端：</p><p>用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。</p></li><li><p>JS解释器 ：</p><p>用来解释执行JS代码；</p></li><li><p>数据存储：</p><p>属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的， 客户端存储技术；</p></li></ol><p><strong>浏览器的核心是两部分</strong>：渲染引擎和 JavaScript 解释器（又称 JavaScript 引擎）</p><h4 id="渲染引擎" tabindex="-1"><a class="header-anchor" href="#渲染引擎"><span>渲染引擎</span></a></h4><p>渲染引擎处理网页，通常分成四个阶段。</p><ol><li>解析代码：HTML 代码解析为 DOM，CSS 代码解析为 CSSOM（CSS Object Model）。</li><li>对象合成：将 DOM 和 CSSOM 合成一棵渲染树（render tree）。</li><li>布局：计算出渲染树的布局（layout）。</li><li>绘制：将渲染树绘制到屏幕。</li></ol><p><em>以上四步并非严格按顺序执行，往往第一步还没完成，第二步和第三步就已经开始了。所以，会看到这种情况：网页的 HTML 代码还没下载完，但浏览器已经显示出内容了。</em></p><h4 id="回流与重绘" tabindex="-1"><a class="header-anchor" href="#回流与重绘"><span>回流与重绘</span></a></h4><p><strong>回流</strong>：DOM元素发生某种变化，渲染树(render tree)重新计算，浏览器对DOM树重新排列(布局改变)</p><p><strong>重绘</strong>：元素的外观发生改变，浏览器会根据元素的新属性重新绘制样式。(布局不改变)</p><p><strong>回流一定发生重绘，重绘不一定发生回流</strong></p><p>优化技巧尽量避免回流与重绘：</p><ul><li>读取 DOM 或者写入 DOM，尽量写在一起，不要混杂。不要读取一个 DOM 节点，然后立刻写入，接着再读取一个 DOM 节点。</li><li>缓存 DOM 信息。</li><li>不要一项一项地改变样式，而是使用 CSS class 一次性改变样式。</li><li>使用<code>documentFragment</code>操作 DOM</li><li>动画使用<code>absolute</code>定位或<code>fixed</code>定位，这样可以减少对其他元素的影响。</li><li>只在必要时才显示隐藏元素。</li><li>使用<code>window.requestAnimationFrame()</code>，因为它可以把代码推迟到下一次重绘之前执行，而不是立即要求页面重绘。</li><li>使用虚拟 DOM（virtual DOM）库。</li></ul><h2 id="javascript运行机制" tabindex="-1"><a class="header-anchor" href="#javascript运行机制"><span>JavaScript运行机制</span></a></h2><h3 id="浏览器的组成-1" tabindex="-1"><a class="header-anchor" href="#浏览器的组成-1"><span>浏览器的组成</span></a></h3><h4 id="浏览器的进程" tabindex="-1"><a class="header-anchor" href="#浏览器的进程"><span>浏览器的进程</span></a></h4><p>浏览器的是多进程的，它的主要进程有：</p><p><strong>1.Browser进程：浏览器的主进程（负责协调、主控），只有一个。</strong></p><ul><li>负责浏览器界面显示，与用户交互。如前进，后退等</li><li>负责各个页面的管理，创建和销毁其他进程</li><li>将Renderer进程得到的内存中的Bitmap，绘制到用户界面上</li><li>网络资源的管理，下载等</li></ul><p><strong>2.第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</strong></p><p><strong>3、GPU进程：最多一个，用于3D绘制等</strong></p><p>4、<strong>浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为：页面渲染，脚本执行，事件处理等</strong></p><blockquote><p>在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程） 当然，浏览器有时会将多个进程合并（譬如打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程）。</p></blockquote><h4 id="浏览器多进程的优势" tabindex="-1"><a class="header-anchor" href="#浏览器多进程的优势"><span>浏览器多进程的优势</span></a></h4><p>相比于单进程浏览器，多进程有如下优点： 1、避免单个page crash影响整个浏览器 2、避免第三方插件crash影响整个浏览器 3、多进程充分利用多核优势 4、方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</p><h4 id="浏览器的内核-渲染进程" tabindex="-1"><a class="header-anchor" href="#浏览器的内核-渲染进程"><span>浏览器的内核-渲染进程</span></a></h4><p>页面的渲染，JS的执行，事件的循环，都在这个进程内进行。</p><p>渲染进程主要包含的线程：</p><p><strong>1.GUI渲染线程</strong></p><ul><li>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</li><li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</li><li>注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</li></ul><p><strong>2.JS引擎线程</strong></p><ul><li>也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）</li><li>JS引擎线程负责解析Javascript脚本，运行代码。</li><li>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</li><li>同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li></ul><p><strong>3.事件触发线程</strong></p><ul><li>归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</li><li>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</li><li>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</li></ul><p><strong>4.定时触发器线程</strong></p><ul><li>传说中的setInterval与setTimeout所在线程</li><li>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</li><li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</li><li>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</li></ul><p><strong>5.异步http请求线程</strong></p><ul><li>在XMLHttpRequest连接后是通过浏览器新开一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由JavaScript引擎执行。</li><li>简单说就是当执行到一个http异步请求时，就把异步请求事件添加到异步请求线程，等收到响应(准确来说应该是http状态变化)，再把回调函数添加到事件队列，等待js引擎线程来执行</li></ul><h3 id="事件循环" tabindex="-1"><a class="header-anchor" href="#事件循环"><span>事件循环</span></a></h3><h4 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h4><p>JS是单线程语言，规定了同一时间只能做一件事情，为什么？</p><p>因为JS是浏览器脚本语言，是用来与用户交互的，操作DOM的。这个特性决定JS是单线程语言，否则会带来很多复杂问题，例如，如果JS是多线程，那么一个线程在DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器是怎么做？所以JS只能是单线程。</p><h4 id="异步" tabindex="-1"><a class="header-anchor" href="#异步"><span>异步</span></a></h4><p>JS为什么需要异步？</p><p>JS代码执行是从上至下，如果有一段代码需要发送请求那么就会阻塞下面的代码执行。用户体验就会很差。</p><p><strong>JS中的异步操作</strong></p><ul><li>定时器（setTimeout）（setInterval）</li><li>回调函数</li><li>监听事件</li><li>AJAX请求</li><li>promise</li><li>生成器函数</li></ul><h4 id="js运行机制" tabindex="-1"><a class="header-anchor" href="#js运行机制"><span>JS运行机制</span></a></h4><p>先判断是同步任务还是异步任务</p><p>JS同步任务在主线程完成，形成一个执行栈（从上至下依次执行）</p><p>异步任务会先推入Event table，当满足特定的条件时（请求状态发生变化，定时器时间到了）就会被推入事件触发线程管理的异步任务队列（Event queue） 注册一个回调函数。一旦执行栈中所有的同步任务执行完成，就会读取任务队列，将可以运行的异步任务（任务队列中的事件回调，只要任务队列中有事件回调，就说明可以执行）添加到执行栈中，开始执行</p><blockquote><p>注意：队列是先进先出</p></blockquote><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/ltw003.png" alt="未命名文件-导出" tabindex="0" loading="lazy"><figcaption>未命名文件-导出</figcaption></figure><h4 id="宏任务与微任务" tabindex="-1"><a class="header-anchor" href="#宏任务与微任务"><span>宏任务与微任务</span></a></h4><p>**宏任务（macrotask）**也叫task</p><p>我们可以将每次执行栈执行的代码当做是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)， 每一个宏任务会从头到尾执行完毕，不会执行其他</p><p>由于<strong>JS引擎线程</strong>和<strong>GUI渲染线程</strong>是互斥的关系，浏览器为了能够使<code>宏任务</code>和<code>DOM任务</code>有序的进行，会在一个<code>宏任务</code>执行结果后，在下一个<code>宏任务</code>执行前，<code>GUI渲染线程</code>开始工作，对页面进行渲染</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>宏任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; ...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>常见的宏任务：</p><ul><li>主代码块（script标签代码）</li><li>setTimeout</li><li>setInterval</li><li>setImmediate ()-Node</li><li>requestAnimationFrame ()-浏览器</li></ul><p><strong>微任务</strong>（microtask）也叫jobs</p><p>微任务是当前宏任务执行完后立即执行的任务，当一个<code>宏任务</code>执行完，会在渲染前，将执行期间所产生的所有<strong>微任务</strong>都执行完</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>宏任务 -&gt; 微任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; ...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>常见微任务：</p><ul><li>process.nextTick ()-Node环境</li><li>Promise.then()</li><li>promise的catch</li><li>promise的finally</li><li>Object.observe</li><li>MutationObserver</li></ul><p><strong>注意点：</strong></p><ul><li><p>浏览器会先执行一个宏任务，紧接着执行当前执行栈产生的微任务，再进行渲染，然后再执行下一个宏任务</p></li><li><p>微任务和宏任务不在一个任务队列，不在一个任务队列</p></li><li><ul><li>例如<code>setTimeout</code>是一个宏任务，它的事件回调在宏任务队列，<code>Promise.then()</code>是一个微任务，它的事件回调在微任务队列，二者并不是一个任务队列</li><li>以Chrome 为例，有关渲染的都是在渲染进程中执行，渲染进程中的任务（DOM树构建，js解析…等等）需要主线程执行的任务都会在主线程中执行，而浏览器维护了一套事件循环机制，主线程上的任务都会放到消息队列中执行，主线程会循环消息队列，并从头部取出任务进行执行，如果执行过程中产生其他任务需要主线程执行的，渲染进程中的其他线程会把该任务塞入到消息队列的尾部，消息队列中的任务都是宏任务</li><li>微任务是如何产生的呢？当执行到script脚本的时候，js引擎会为全局创建一个执行上下文，在该执行上下文中维护了一个微任务队列，当遇到微任务，就会把微任务回调放在微队列中，当所有的js代码执行完毕，在退出全局上下文之前引擎会去检查该队列，有回调就执行，没有就退出执行上下文，这也就是为什么微任务要早于宏任务，也是大家常说的，每个宏任务都有一个微任务队列（由于定时器是浏览器的API，所以定时器是宏任务，在js中遇到定时器会也是放入到浏览器的队列中</li></ul></li></ul><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-858bcd85eb943a853cdbaf3ba7227985_720w.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>完整的Event Loop</strong></p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/ltw001.png" alt="ltw001" tabindex="0" loading="lazy"><figcaption>ltw001</figcaption></figure><h3 id="垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#垃圾回收机制"><span>垃圾回收机制</span></a></h3><h4 id="_1-引用计数法" tabindex="-1"><a class="header-anchor" href="#_1-引用计数法"><span>1.引用计数法</span></a></h4><p><strong>引用计数法</strong>：如果有一个变量，指向访问我的一块内存空间，计数器就会加1，如果计数器为0，就会被立即清除</p><p>存在于低版本的浏览器（IE8以下）</p><p>优点：</p><ul><li>时刻检测内存变化</li><li>能够降低内存卡顿情况</li></ul><p>缺点：</p><ul><li>性能开销大</li><li>造成循环引用问题（计数器不会为零无法被清除）</li></ul><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/Snipaste_2022-11-01_21-33-21.png" alt="Snipaste_2022-11-01_21-33-21" tabindex="0" loading="lazy"><figcaption>Snipaste_2022-11-01_21-33-21</figcaption></figure><h4 id="_2-标记清除法" tabindex="-1"><a class="header-anchor" href="#_2-标记清除法"><span>2.标记清除法</span></a></h4><p><strong>标记清除法</strong>：分为两个阶段</p><p>标记阶段：垃圾回收器会从根对象开始扫描(在js中，通常认定全局对象window做为根)。每一个可以从根对象访问到的对象都会被添加一个标识，于是这个对象就被标识为可到达对象。</p><p>清除阶段：垃圾回收器会对堆内存从头到尾进行线性遍历，如果发现有对象没有被标识为可到达对象，那么就将此对象占用的内存回收，并且将原来标记为可到达对象的标识清除，以便进行下一次垃圾回收操作。</p><p>优点：解决了循环引用问题</p><p>缺点：内存碎片化问题</p><p>内存碎片</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220319163559599-1442669422.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>那如何找到合适的块呢？我们可以采取下面三种分配策略</p><ul><li><code>First-fit</code>，找到大于等于 <code>size</code> 的块立即返回</li><li><code>Best-fit</code>，遍历整个空闲列表，返回大于等于 <code>size</code> 的最小分块</li><li><code>Worst-fit</code>，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 <code>size</code> 大小，并将该部分返回</li></ul><p><strong>标记整理法</strong>：与标记清除法理解一致，不同处在清除之前，会进行整理</p><p>优点：解决内存碎片化</p><p>缺点：性能消耗大，每次清除前，都要去整理内存</p><h4 id="_3-v8引擎的回收机制" tabindex="-1"><a class="header-anchor" href="#_3-v8引擎的回收机制"><span>3.V8引擎的回收机制</span></a></h4><p>Chrome 浏览器所使用的 V8 引擎采用的<strong>分代回收</strong>策略，将对象区分为<strong>临时对象</strong>（新生代）和<strong>持久对象</strong>（老生代）；多回收临时对象，少回收持久对象</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320223409481-985539086.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>新生代对象特点：</p><ul><li>通常把小的对象分配到新生代</li><li>新生代的垃圾回收比较频繁</li><li>通常存储容量在1~8M</li></ul><p>新生代-<code>Scavenge</code>算法：</p><p>该算法将新生代分为两部分，一部分叫做from（对象区域），另一部分叫做to（空闲区域），新加入的对象首先存放在from区域</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320222512252-618938289.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>from区域写满的时候，对from区域开始进行垃圾回收。首先对from区域的垃圾进行标记(红色代表标记为垃圾)</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320222532461-104056076.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>将存活的对象复制到to区域中，并且有序地排列起来，复制后的to区域就没有内存碎片了</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320222624767-871994632.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>清空from区域，from区域和to区域进行反转。from区域变为to区域，原来的to区域变成from区域</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320222844769-1929737231.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>特点：效率高，缺点是只能使用堆内存的一半，如果存储量过大效率会导致清理时间变长，效率低。所以经过两次回收后还存活的对象会晋升为老生代对象。</p><p>另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 <code>Scavenge</code> 回收后，空闲区将翻转成对象区域，继续进行对象内存的分配，若占比过大，将会影响后续内存分配。</p><p>老生代对象特点：</p><ul><li>对象占用空间大</li><li>对象存活时间长</li></ul><p>老生代-标记整理法</p><p><strong>何时执行垃圾回收</strong></p><p>由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿。</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320224732161-2073439953.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/1155527-20220320224800732-1238024954.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="浏览器缓存机制" tabindex="-1"><a class="header-anchor" href="#浏览器缓存机制"><span>浏览器缓存机制</span></a></h2><h3 id="缓存概述" tabindex="-1"><a class="header-anchor" href="#缓存概述"><span>缓存概述</span></a></h3><h4 id="什么是缓存" tabindex="-1"><a class="header-anchor" href="#什么是缓存"><span>什么是缓存？</span></a></h4><p>缓存是一种<strong>保存资源副本</strong>并在<strong>下次请求直接使用该副本</strong>的技术。</p><h4 id="为什么使用缓存-作用" tabindex="-1"><a class="header-anchor" href="#为什么使用缓存-作用"><span>为什么使用缓存？作用</span></a></h4><p>网络请求速度会受到服务器的性能、网络的带宽、网络条件、以及网络链路的距离等的影响。</p><p><strong>缓存的作用</strong>：</p><ul><li>降低了对原始服务器的要求。缓存设备可以更快地响应用户，同时避免服务器过载的出现。</li><li>减少网络上冗余的数据传输，节省网络费用。</li><li>缓解了网络瓶颈的问题。不需要更多的带宽就能够更快地加载页面。</li><li>降低了距离时延，因为请求链路距离会更短，距离短传输速度会比较快。</li></ul><h3 id="缓存的位置" tabindex="-1"><a class="header-anchor" href="#缓存的位置"><span>缓存的位置</span></a></h3><p>浏览器缓存通过 HTTP/HTTPS 实现，存储位置有四种：</p><ul><li>Service Worker</li><li>Memory Cache（内存缓存）</li><li>Disk Cache（硬盘缓存）</li><li>Push Cache（推送缓存）</li></ul><p>以上缓存全部没有命中就会进行网络请求。</p><h4 id="service-worker" tabindex="-1"><a class="header-anchor" href="#service-worker"><span>Service Worker</span></a></h4><p>Service Worker 是运行在浏览器背后的独立线程，可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</p><h4 id="memory-cache" tabindex="-1"><a class="header-anchor" href="#memory-cache"><span>Memory Cache</span></a></h4><p>Memory Cache 是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据高效，但是缓存持续性很短。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。而且由于计算机中的内存比硬盘容量小得多，我们能够使用存储缓存的内存并不多。</p><p>内存缓存在缓存资源时并不关心返回资源的 HTTP 缓存头 Cache-Control，同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 Content-Type，CORS 等其他特征做校验。</p><h4 id="disk-cache" tabindex="-1"><a class="header-anchor" href="#disk-cache"><span>Disk Cache</span></a></h4><p>Disk Cache 是存储在硬盘中的缓存，读取速度比 Memory Cache 慢，但是存储量更大。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。</p><h4 id="push-cache" tabindex="-1"><a class="header-anchor" href="#push-cache"><span>Push Cache</span></a></h4><p>Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。<strong>它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂</strong>，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。</p><p><strong>浏览器什么时候会把缓存存储到内存中，什么时候存储到硬盘中呢？一般来说：</strong></p><ul><li>小文件优先存储到内存中，反之存储到硬盘中</li><li>使用频率高的缓存到硬盘中</li></ul><p>Disk Cache严格遵守HTTP缓存规则。</p><h3 id="缓存有效性" tabindex="-1"><a class="header-anchor" href="#缓存有效性"><span>缓存有效性</span></a></h3><h4 id="命中与未命中" tabindex="-1"><a class="header-anchor" href="#命中与未命中"><span>命中与未命中</span></a></h4><p>缓存无法保存Web的所有文档，即使有，文档也会发生变化，很多缓存也不能及时地进行更新。缓存无法为所有的请求提供服务。</p><p>当已有的副本为到达缓存的请求提供服务，称为<strong>缓存命中（cache hit）</strong></p><p>如果到达缓存的请求没有副本可用，而被转发给原始服务器，被称为<strong>缓存未命中（cache miss）</strong></p><h4 id="再验证" tabindex="-1"><a class="header-anchor" href="#再验证"><span>再验证</span></a></h4><p>原来的服务器内容可能会发生变化，缓存要对其检测，看看保存的副本是否还是服务器的最新副本，这个检测也被称为<strong>HTTP再验证</strong></p><p>再验证分为三种情况：</p><p>1.再验证命中</p><p>如果服务器对象未被修改，服务器会向客户端发送一个小的 HTTP 304 Not Modified 响应。</p><p>2.再验证未命中</p><p>如果服务器对象与已缓存副本不同，服务器向客户端发送一条普通的、带有完整内容的 HTTP 200 OK 响应。</p><p>3.对象被删除</p><p>如果服务器对象已经被删除了，服务器就回送一个 404 Not Found 响应，缓存也会将其副本删除</p><h4 id="区分响应应来自缓存还是服务器" tabindex="-1"><a class="header-anchor" href="#区分响应应来自缓存还是服务器"><span>区分响应应来自缓存还是服务器</span></a></h4><p>客户端可以通过三个响应头来区分是缓存还是服务器返回：</p><ul><li><strong>Via 首部</strong>。有些商业代理缓存会在 Via 首部附加一些额外信息来描述缓存中发生的情况。</li><li><strong>Date 首部</strong>。指的是服务器响应生成的时间。将响应中 Date 首部的值与当前时间进行比较，如果响应中的日期值比较早，通常就可以认为是来自缓存的响应。</li><li><strong>Age 首部</strong>。客户端也可以通过 Age 首部来检测缓存的响应，指的是代理服务器对于请求资源的已缓存时间, 单位为秒</li></ul><h3 id="缓存拓扑结构" tabindex="-1"><a class="header-anchor" href="#缓存拓扑结构"><span>缓存拓扑结构</span></a></h3><h4 id="私有缓存和公有缓存" tabindex="-1"><a class="header-anchor" href="#私有缓存和公有缓存"><span>私有缓存和公有缓存</span></a></h4><p>缓存可以是单个用户专用的，也可以是数千名用户共享的。 把缓存的服务范围进行分类，可以分为私有缓存与公有缓存。</p><p><strong>私有缓存</strong></p><p>私有缓存（private cache）也被称为专用缓存，包含了单个用户最常用的页面。 私有缓存不需要很大的处理能力或存储空间，这样它的成本就能比较低。 Web 浏览器中有内建的私有缓存——大多数浏览器都会将常用文档缓存在你个人电脑的磁盘和内存中，并且允许用户去配置缓存的大小和各种设置。还可以去看看浏览器的缓存中有些什么内容。</p><p><strong>公有缓存</strong></p><p><strong>公有缓存</strong>被称为<strong>缓存代理服务器（caching proxy server）</strong>，或者被称为<strong>代理缓存（proxy cache）</strong>，包含了一个群体的常用页面。代理缓存会从缓存服务器本地提供文档，或者代表用户与服务器进行联系。公有缓存会接受来自<strong>多个用户</strong>的访问，所以通过它可以更好地减少冗余流量。</p><p>代理缓存可以通过指定手工代理，或者通过代理自动配置文件，将你的浏览器配置为使用代理缓存。还可以通过使用拦截代理在不配置浏览器的情况下，强制 HTTP 请求经过缓存传输。</p><p><strong>层级结构和网状结构</strong></p><p>层次化的缓存结构和网状的缓存结构</p><h3 id="缓存的处理步骤" tabindex="-1"><a class="header-anchor" href="#缓存的处理步骤"><span>缓存的处理步骤</span></a></h3><ol><li>接受：从网络中读取抵达的请求报文</li><li>解析：对报文进行解析，提取出url和各种首部</li><li>查询：查询本地是否有缓存副本，如果没有，就请求上级缓存代理或者请求源服务器。完成后保存至本地。</li><li>新鲜度检测：查看本地一缓存的副本是否足够新鲜，如果不是，就像源服务器请求是否有更新</li><li>创建响应：缓存服务器重新构建响应首部</li><li>发送：将响应报文发送给客户端</li><li>日志：记录日志</li></ol><h3 id="缓存类型" tabindex="-1"><a class="header-anchor" href="#缓存类型"><span>缓存类型</span></a></h3><h4 id="强制缓存" tabindex="-1"><a class="header-anchor" href="#强制缓存"><span><strong>强制缓存</strong></span></a></h4><p>强制缓存是在浏览器加载资源的时候，先检查缓存时间是否过期，若未过期则直接从缓存中查找请求结果，如果缓存时间过期或不存在该缓存结果，则向服务端发起请求。</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-9d213cea6613d3ebdefed4ba1f58a43d_r.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>设置缓存时间（响应头字段）</strong></p><ul><li>Expires（HTTP/1.0）</li><li>Cache-Control（HTTP/1.1）</li></ul><h4 id="expires" tabindex="-1"><a class="header-anchor" href="#expires"><span>Expires</span></a></h4><p>HTTP/1.0 中使用响应头部字段 Expires 来设置缓存过期时间。客户端第一次请求时，服务端会在响应头部添加 Expires 字段。当浏览器再次发送请求时，先会对比当前时间和 Expires 对应的时间，如果当前时间早于 Expires 时间，那么直接使用缓存；反之，需要再次发送请求。</p><p>出现的问题：</p><ul><li>服务端和浏览器的时间可能不同，导致缓存过期时间出现偏差</li><li>客户端可以通过修改系统时间来继续使用缓存或提前使缓存失效</li></ul><h4 id="cache-control" tabindex="-1"><a class="header-anchor" href="#cache-control"><span>Cache-Control</span></a></h4><ul><li><code>no-cache</code>：表示使用协商缓存，即每次使用缓存前必须向服务端确认缓存资源是否更新；</li><li><code>no-store</code>：禁止浏览器以及所有中间缓存存储响应内容；</li><li><code>public</code>：公有缓存，表示可以被代理服务器缓存，可以被多个用户共享；</li><li><code>private</code>：私有缓存，不能被代理服务器缓存，不可以被多个用户共享；</li><li><code>max-age</code>：以秒为单位的数值，表示缓存的有效时间；</li><li><code>must-revalidate</code>：当缓存过期时，需要去服务端校验缓存的有效性。</li></ul><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-98a1ce2905ce1c0d1358a28b73b60f5b_720w.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>此 Cache-Control 信息告诉浏览器该缓存为公有缓存，有效期 1 年。</p><p><strong>200 状态码一定是服务器返回的吗？</strong></p><p><strong>不是</strong>。命中强缓存的话，会直接从内存或者磁盘中读取资源，并返回一个200状态码，具体操作可以试试浏览器的前进后退键。</p><h4 id="协商缓存" tabindex="-1"><a class="header-anchor" href="#协商缓存"><span>协商缓存</span></a></h4><p>协商缓存不指定缓存的有效时间，而是在请求时直接发送资源标识到服务端确认缓存是否需要更新，如果请求响应返回的 HTTP 状态为 304，则表示缓存仍然有效；否则返回状态码 200 、最新的资源和最新的资源标识。</p><p>控制缓存的难题就从浏览器端转移到了服务端</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-6c0b82ec07fcc384fa011b5a04f4e384_r.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>资源标识（在 Response Header 中）有两种</strong></p><ul><li>Last-Modified：资源的最后修改时间</li><li>Etag：资源的唯一标识（一个字符串）</li></ul><h4 id="last-modified-和-if-modified-since" tabindex="-1"><a class="header-anchor" href="#last-modified-和-if-modified-since"><span>Last-Modified 和 If-Modified-Since</span></a></h4><p>服务端通过响应头部字段 Last-Modified 和请求头部字段 If-Modified-Since 比对双方资源的修改时间，来确定缓存是否需要更新。具体工作流程如下：</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-e7c5b4ea204be53364f72ef03fef6fbd_r.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ol><li>浏览器第一次请求资源，服务端在返回资源的响应头中加入 Last-Modified 字段，表示这个资源在服务端上的最近修改时间；</li><li>当浏览器再次向服务端请求该资源时，请求头部带上之前服务端返回的 Last-Modified，这个请求头叫 If-Modified-Since；</li><li>服务端再次收到请求，根据 If-Modified-Since 的值，判断相关资源是否有变化，如果没有，则返回 304 Not Modified，浏览器使用资源缓存值；否则返回资源内容，且更新 Last-Modified 响应头内容。</li></ol><p>这种方式虽然能判断缓存是否失效，但也存在三个问题：</p><ol><li>精度问题：Last-Modified 的时间精度为秒，如果在 1 秒内发生修改，那么缓存判断会失效</li><li>准度问题：如果一个文件被修改后又被还原，内容没有发生变化，却仍然需要重新请求</li><li>服务器问题：某些服务器不能精确的得到文件的最后修改时间</li></ol><h4 id="etag-和-if-none-match" tabindex="-1"><a class="header-anchor" href="#etag-和-if-none-match"><span>ETag 和 If-None-Match</span></a></h4><p>为了解决精度问题和准度问题，HTTP 提供了另一种依赖于文件哈希值的精确判断缓存的方式：响应头部字段 ETag 和请求头部字段 If-None-Match。具体工作流程如下：</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-3e1da5789e1743643ee8c0ed8487660e_r.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ol><li>浏览器第一次请求资源，服务端在返响应头中加入 Etag 字段，Etag 字段值为该资源的哈希值；</li><li>当浏览器再次跟服务端请求这个资源时，在请求头上加上 If-None-Match，值为之前响应头部字段 ETag 的值；</li><li>服务端再次收到请求，将请求头 If-None-Match 字段的值和响应资源的哈希值进行比对，如果两个值相同，则说明资源没有变化，返回 304 Not Modified；否则就正常返回资源内容，无论是否发生变化，都会将计算出的哈希值放入响应头部的 ETag 字段中。</li></ol><p>缺点：</p><ul><li>计算成本。对于大文件而言，读取完整的文件内容生成哈希值开销较大；只读取文件部分内容，又容易判断出错。</li><li>计算误差。不同服务端可能会采用不同的哈希值计算方式。所以同一个资源在两台服务端产生的 Etag 可能是不相同的。对于使用服务器集群来处理请求的网站来说，使用 Etag 的缓存命中率会有所降低。</li></ul><p>两者中会优先使用 Etag：</p><ul><li>Last-Modified 只能精确到秒级</li><li>如果资源被重复生成，而内容不变，Etag 更加精准</li></ul><p><strong>缓存的优先级：</strong></p><ul><li><p>强制缓存的优先级高于协商缓存:</p></li><li><ul><li>强制缓存中：cache-control 的 max-age 优先级高于 Expires</li><li>协商缓存中：Etag 优先级比 Last-Modified 高。</li></ul></li><li><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/流程图-导出.png" alt="流程图-导出" tabindex="0" loading="lazy"><figcaption>流程图-导出</figcaption></figure></li></ul><h4 id="用户行为" tabindex="-1"><a class="header-anchor" href="#用户行为"><span>用户行为</span></a></h4><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/v2-73241506477c2bb5b47cb99f93f28caa_720w.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="禁用缓存" tabindex="-1"><a class="header-anchor" href="#禁用缓存"><span>禁用缓存</span></a></h4><p>服务器禁用缓存：</p><ul><li>Cache-Control: max-age=0, must-revalidate</li><li>Cache-Control: no-cache</li><li>Cache-Control: no-store</li></ul><p>浏览器禁用缓存：</p><ul><li>改变 url，加上<code>?xi=xixi</code></li><li>设置请求 header</li></ul><h2 id="js执行上下文与执行栈" tabindex="-1"><a class="header-anchor" href="#js执行上下文与执行栈"><span>JS执行上下文与执行栈</span></a></h2><h3 id="概述-1" tabindex="-1"><a class="header-anchor" href="#概述-1"><span>概述</span></a></h3><h4 id="什么是执行上下文" tabindex="-1"><a class="header-anchor" href="#什么是执行上下文"><span>什么是执行上下文？</span></a></h4><p>执行上下文就是当前JS代码被解析和运行时所在的<strong>环境</strong>的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。</p><p>声明周期：创建-执行-销毁</p><h4 id="三种全局上写下文" tabindex="-1"><a class="header-anchor" href="#三种全局上写下文"><span>三种全局上写下文</span></a></h4><ol><li>全局执行上下文</li><li>函数执行上下文</li><li>eval 执行上下文</li></ol><h3 id="详细功能" tabindex="-1"><a class="header-anchor" href="#详细功能"><span>详细功能</span></a></h3><h4 id="全局执行上下文" tabindex="-1"><a class="header-anchor" href="#全局执行上下文"><span>全局执行上下文</span></a></h4><p>全局执行上下文是在全局的代码执行前,JS引擎自动进行的工作</p><p>第一步：将<code>window对象</code>指定为全局执行上下文对象</p><p>第二步：对在全局作用域中的数据进行<strong>预处理</strong></p><ol><li>收集所有在<strong>全局作用域</strong>中使用<strong>var</strong>关键字定义的变量,将值赋值为<code>undefined</code>,并添加成为<code>全局执行上下文对象window</code>的属性</li><li>收集所有在全局作用域中使用function关键字申明的函数,添加成为<code>全局执行上下文对象window</code>的方法</li><li>将上下文对象指向全局执行上下文对象, 即: this = window</li></ol><p>第三步：开始执行全局代码,变量赋值的正常赋值,语句、表达式等执行的执行</p><h4 id="局部-函数-执行上下文" tabindex="-1"><a class="header-anchor" href="#局部-函数-执行上下文"><span>局部(函数)执行上下文</span></a></h4><p>在函数调用之后，执行代码之前创建函数执行上下文</p><p>第一步：对函数内部中的变量、参数进行预处理</p><ol><li>形参变量会被赋值成实参的值,然后添加成为函数执行上下文对象的属性</li><li>arguments对象被赋值由实参组成的伪数组,然后添加成为函数执行上下文对象的属性</li><li><code>var</code>关键字申明的变量与<code>function</code>关键字申明的函数,与全局执行上下文状况类似,但是被限制在了函数作用域中</li></ol><p>第二步：上下文对象根据调用函数的对象,动态变化 即: this是动态变化的</p><p>第三步：执行函数体代码</p><h4 id="执行上下文创建" tabindex="-1"><a class="header-anchor" href="#执行上下文创建"><span>执行上下文创建</span></a></h4><p>分为创建阶段执行阶段</p><p>创建过程：主要负责三件事</p><ol><li>确定this</li><li>创建词法环境组件（LexicalEnvironment）</li><li>创建变量环境组件（VariableEnvironment）</li></ol><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>ExecutionContext <span class="token operator">=</span> <span class="token punctuation">{</span>  
    <span class="token comment">// 确定this的值</span>
    ThisBinding <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token keyword">this</span> value<span class="token operator">&gt;</span><span class="token punctuation">,</span>
    <span class="token comment">// 创建词法环境组件</span>
    LexicalEnvironment <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 创建变量环境组件</span>
    VariableEnvironment <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>确定this</strong></p><p>1.在全局执行上下文中，this总是指向全局对象，例如浏览器环境下this指向window对象。</p><p>2.而在函数执行上下文中，this的值取决于函数的调用方式，如果被一个对象调用，那么this指向这个对象。否则this一般指向全局对象window或者undefined（严格模式）。</p><p><strong>词法环境组件</strong></p><p>1.词法环境是一个包含标识符变量映射的结构，这里的标识符表示变量/函数的名称，变量是对实际对象【包括函数类型对象】或原始值的引用。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">444</span> 
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// 标识符a 映射 Number类型的值444</span>
<span class="token comment">// 标识符b 映射 对象所在堆内存的地址值</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2.词法环境由<strong>环境记录</strong>与<strong>对外部环境引入记录</strong>两个部分组成。</p><p>3.其中环境记录用于存储当前环境中的变量和函数声明的实际位置；外部环境引入记录很好理解，它用于保存自身环境可以访问的其它外部环境(作用域链)</p><p>4.词法环境分为全局词法环境与函数词法环境两种。</p><p><strong>(1)全局词法环境</strong>：</p><p>对外部环境的引入记录为null，因为它本身就是最外层环境，除此之外它还记录了当前环境下的所有属性、方法位置</p><p><strong>(2)函数词法环境组件：</strong></p><p>包含了用户在函数中定义的所有属性方法外，还包含了一个arguments对象。函数词法环境的外部环境引入可以是全局环境，也可以是其它函数环境</p><p><strong>变量环境组件</strong></p><p>变量环境可以说也是词法环境，它具备词法环境所有属性，一样有环境记录与外部环境引入，在ES6中唯一的区别在于词法环境用于存储函数声明与let const声明的变量，而变量环境仅仅存储var声明的变量。</p><p>伪代码形式描述：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">//全局执行上下文</span>
GlobalExectionContext <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// this绑定为全局对象</span>
    <span class="token literal-property property">ThisBinding</span><span class="token operator">:</span> <span class="token operator">&lt;</span>Global Object<span class="token operator">&gt;</span><span class="token punctuation">,</span>
    <span class="token comment">// 词法环境</span>
    <span class="token literal-property property">LexicalEnvironment</span><span class="token operator">:</span> <span class="token punctuation">{</span>  
        <span class="token comment">//环境记录</span>
      <span class="token literal-property property">EnvironmentRecord</span><span class="token operator">:</span> <span class="token punctuation">{</span>  
        <span class="token literal-property property">Type</span><span class="token operator">:</span> <span class="token string">&quot;Object&quot;</span><span class="token punctuation">,</span>  <span class="token comment">// 对象环境记录</span>
        <span class="token comment">// 标识符绑定在这里 let const创建的变量a b在这</span>
        <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token operator">&lt;</span> uninitialized <span class="token operator">&gt;</span><span class="token punctuation">,</span>  
        <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token operator">&lt;</span> uninitialized <span class="token operator">&gt;</span><span class="token punctuation">,</span>  
        <span class="token literal-property property">multiply</span><span class="token operator">:</span> <span class="token operator">&lt;</span> func <span class="token operator">&gt;</span>  
      <span class="token punctuation">}</span>
      <span class="token comment">// 全局环境外部环境引入为null</span>
      <span class="token literal-property property">outer</span><span class="token operator">:</span> <span class="token operator">&lt;</span><span class="token keyword">null</span><span class="token operator">&gt;</span>  
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  
    <span class="token literal-property property">VariableEnvironment</span><span class="token operator">:</span> <span class="token punctuation">{</span>  
      <span class="token literal-property property">EnvironmentRecord</span><span class="token operator">:</span> <span class="token punctuation">{</span>  
        <span class="token literal-property property">Type</span><span class="token operator">:</span> <span class="token string">&quot;Object&quot;</span><span class="token punctuation">,</span>  <span class="token comment">// 对象环境记录</span>
        <span class="token comment">// 标识符绑定在这里  var创建的c在这</span>
        <span class="token literal-property property">c</span><span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>  
      <span class="token punctuation">}</span>
      <span class="token comment">// 全局环境外部环境引入为null</span>
      <span class="token literal-property property">outer</span><span class="token operator">:</span> <span class="token operator">&lt;</span><span class="token keyword">null</span><span class="token operator">&gt;</span>  
    <span class="token punctuation">}</span>  
  <span class="token punctuation">}</span>

  <span class="token comment">// 函数执行上下文</span>
  FunctionExectionContext <span class="token operator">=</span> <span class="token punctuation">{</span>
     <span class="token comment">//由于函数是默认调用 this绑定同样是全局对象</span>
    <span class="token literal-property property">ThisBinding</span><span class="token operator">:</span> <span class="token operator">&lt;</span>Global Object<span class="token operator">&gt;</span><span class="token punctuation">,</span>
    <span class="token comment">// 词法环境</span>
    <span class="token literal-property property">LexicalEnvironment</span><span class="token operator">:</span> <span class="token punctuation">{</span>  
      <span class="token literal-property property">EnvironmentRecord</span><span class="token operator">:</span> <span class="token punctuation">{</span>  
        <span class="token literal-property property">Type</span><span class="token operator">:</span> <span class="token string">&quot;Declarative&quot;</span><span class="token punctuation">,</span>  <span class="token comment">// 声明性环境记录</span>
        <span class="token comment">// 标识符绑定在这里  arguments对象在这</span>
        <span class="token literal-property property">Arguments</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token literal-property property">length</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  
      <span class="token punctuation">}</span><span class="token punctuation">,</span>  
      <span class="token comment">// 外部环境引入记录为&lt;/Global&gt;</span>
      <span class="token literal-property property">outer</span><span class="token operator">:</span> <span class="token operator">&lt;</span>GlobalEnvironment<span class="token operator">&gt;</span>  
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  
    <span class="token literal-property property">VariableEnvironment</span><span class="token operator">:</span> <span class="token punctuation">{</span>  
      <span class="token literal-property property">EnvironmentRecord</span><span class="token operator">:</span> <span class="token punctuation">{</span>  
        <span class="token literal-property property">Type</span><span class="token operator">:</span> <span class="token string">&quot;Declarative&quot;</span><span class="token punctuation">,</span>  <span class="token comment">// 声明性环境记录</span>
        <span class="token comment">// 标识符绑定在这里  var创建的g在这</span>
        <span class="token literal-property property">g</span><span class="token operator">:</span> <span class="token keyword">undefined</span>  
      <span class="token punctuation">}</span><span class="token punctuation">,</span>  
      <span class="token comment">// 外部环境引入记录为&lt;/Global&gt;</span>
      <span class="token literal-property property">outer</span><span class="token operator">:</span> <span class="token operator">&lt;</span>GlobalEnvironment<span class="token operator">&gt;</span>  
    <span class="token punctuation">}</span>  
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="执行上下文栈" tabindex="-1"><a class="header-anchor" href="#执行上下文栈"><span>执行上下文栈</span></a></h4><p>首先JS代码执行前会先创建全局执行上下文，执行栈用于存放所有的执行下上下文，全局执行上下文先入栈，遇到函数调用创建函数执行上下文，压入栈顶，先执行栈顶部的上下文，从上往下依次执行，最后执行全局上下文</p><figure><img src="https://raw.githubusercontent.com/molimaMCc/Image/main/imgs/执行上下文.png" alt="执行上下文" tabindex="0" loading="lazy"><figcaption>执行上下文</figcaption></figure></div><!--[--><!----><!--]--><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/vuepress-theme-hope/vuepress-theme-hope/edit/main/src/base/JavaScript/JavaScript与浏览器原理.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><!----><!----></div></footer><nav class="vp-page-nav"><a class="route-link nav-link prev" href="/Blog/base/JavaScript/ES6.html" aria-label="ES6"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->ES6</div></a><a class="route-link nav-link next" href="/Blog/base/JavaScript/TypeScript.html" aria-label="TypeScript"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">TypeScript<!----></div></a></nav><div id="vp-comment" class="giscus-wrapper input-top" style="display:block;"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" preserveAspectRatio="xMidYMid" viewBox="0 0 100 100"><circle cx="28" cy="75" r="11" fill="currentColor"><animate attributeName="fill-opacity" begin="0s" dur="1s" keyTimes="0;0.2;1" repeatCount="indefinite" values="0;1;1"></animate></circle><path fill="none" stroke="#88baf0" stroke-width="10" d="M28 47a28 28 0 0 1 28 28"><animate attributeName="stroke-opacity" begin="0.1s" dur="1s" keyTimes="0;0.2;1" repeatCount="indefinite" values="0;1;1"></animate></path><path fill="none" stroke="#88baf0" stroke-width="10" d="M28 25a50 50 0 0 1 50 50"><animate attributeName="stroke-opacity" begin="0.2s" dur="1s" keyTimes="0;0.2;1" repeatCount="indefinite" values="0;1;1"></animate></path></svg></div><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer">默认页脚</div><div class="vp-copyright">Copyright © 2024 取名花光钱 </div></footer></div><!--]--><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/Blog/assets/app-otQn-0y1.js" defer></script>
  </body>
</html>
